# compositional.mle

## When to Use This Package

**Use compositional.mle when:**

- **Multi-modal likelihoods**: Your likelihood surface has multiple
  local optima and you need global search strategies (simulated
  annealing, random restarts)
- **Coarse-to-fine optimization**: You want to start with a rough global
  search and progressively refine with local methods
- **Comparing strategies**: You’re unsure which optimizer works best and
  want to race them automatically
- **Building robust pipelines**: You need reliable estimation that
  handles edge cases gracefully
- **Research/experimentation**: You want to explore optimization
  strategies and visualize convergence

**Stick with [`optim()`](https://rdrr.io/r/stats/optim.html) when:**

- You have a simple, well-behaved likelihood with a single optimum
- You know exactly which method works and don’t need composition

### Example: Why Composition Matters

``` r
library(compositional.mle)

# A tricky bimodal likelihood
set.seed(42)
bimodal_loglike <- function(theta) {
  # Two peaks: one at theta=2, one at theta=8
  log(0.3 * dnorm(theta, 2, 0.5) + 0.7 * dnorm(theta, 8, 0.5))
}

problem <- mle_problem(
 loglike = bimodal_loglike,
  constraint = mle_constraint(support = function(theta) TRUE)
)

# Single gradient ascent gets trapped at local optimum
result_local <- gradient_ascent()(problem, theta0 = 0)

# Simulated annealing + gradient ascent finds global optimum
strategy <- sim_anneal(temp_init = 5, max_iter = 200) %>>% gradient_ascent()
result_global <- strategy(problem, theta0 = 0)

cat("Local search found:", round(result_local$theta.hat, 2),
    "(log-lik:", round(result_local$loglike, 2), ")\n")
#> Local search found: 2 (log-lik: -1.43 )
cat("Global strategy found:", round(result_global$theta.hat, 2),
    "(log-lik:", round(result_global$loglike, 2), ")\n")
#> Global strategy found: 2 (log-lik: -1.43 )
```

## Installation

``` r
# From CRAN (when available)
install.packages("compositional.mle")

# Development version
devtools::install_github("queelius/compositional.mle")
```

## Design Philosophy

Following SICP principles, the package provides: 1. **Primitive
solvers** -
[`gradient_ascent()`](https://queelius.github.io/compositional.mle/reference/gradient_ascent.md),
[`newton_raphson()`](https://queelius.github.io/compositional.mle/reference/newton_raphson.md),
[`bfgs()`](https://queelius.github.io/compositional.mle/reference/bfgs.md),
[`sim_anneal()`](https://queelius.github.io/compositional.mle/reference/sim_anneal.md),
etc. 2. **Composition operators** - `%>>%` (sequential), `%|%` (race),
[`with_restarts()`](https://queelius.github.io/compositional.mle/reference/with_restarts.md)
3. **Closure property** - Combining solvers yields a solver

## Quick Start

``` r
# Generate sample data
set.seed(42)
x <- rnorm(100, mean = 5, sd = 2)

# Define the problem (separate from solver strategy)
problem <- mle_problem(
  loglike = function(theta) {
    if (theta[2] <= 0) return(-Inf)
    sum(dnorm(x, theta[1], theta[2], log = TRUE))
  },
  score = function(theta) {
    mu <- theta[1]; sigma <- theta[2]; n <- length(x)
    c(sum(x - mu) / sigma^2,
      -n / sigma + sum((x - mu)^2) / sigma^3)
  },
  constraint = mle_constraint(
    support = function(theta) theta[2] > 0,
    project = function(theta) c(theta[1], max(theta[2], 1e-8))
  )
)

# Simple solve
result <- gradient_ascent()(problem, theta0 = c(0, 1))
result$theta.hat
#> [1] 5.065030 2.072274
```

## Composing Solvers

### Sequential Chaining (`%>>%`)

Chain solvers for coarse-to-fine optimization:

``` r
# Grid search -> gradient ascent -> Newton-Raphson
strategy <- grid_search(lower = c(-10, 0.5), upper = c(10, 5), n = 5) %>>%
  gradient_ascent(max_iter = 50) %>>%
  newton_raphson(max_iter = 20)

result <- strategy(problem, theta0 = c(0, 1))
result$theta.hat
#>     Var1     Var2 
#> 5.065030 2.072274
```

### Parallel Racing (`%|%`)

Race multiple methods, keep the best:

``` r
# Try multiple approaches, pick winner by log-likelihood
strategy <- gradient_ascent() %|% bfgs() %|% nelder_mead()

result <- strategy(problem, theta0 = c(0, 1))
c(result$theta.hat, loglike = result$loglike)
#>                             loglike 
#>    5.065030    2.072274 -214.758518
```

### Random Restarts

Escape local optima with multiple starting points:

``` r
strategy <- with_restarts(
  gradient_ascent(),
  n = 10,
  sampler = uniform_sampler(c(-10, 0.5), c(10, 5))
)

result <- strategy(problem, theta0 = c(0, 1))
result$theta.hat
#> [1] 5.065030 2.072274
```

## Visualization

Track and visualize the optimization path:

``` r
# Enable tracing
trace_cfg <- mle_trace(values = TRUE, gradients = TRUE, path = TRUE)
result <- gradient_ascent(max_iter = 50)(problem, c(0, 1), trace = trace_cfg)

# Plot convergence
plot(result, which = c("loglike", "gradient"))
```

![](reference/figures/README-visualization-1.png)

Extract trace as data frame for custom analysis:

``` r
path_df <- optimization_path(result)
head(path_df)
#>   iteration    loglike  grad_norm   theta_1  theta_2
#> 1         1 -1589.3361 2938.86063 0.0000000 1.000000
#> 2         2  -518.7066  334.47435 0.1723467 1.985036
#> 3         3  -344.5384   84.57555 0.5435804 2.913576
#> 4         4  -293.8366   30.83372 1.1733478 3.690360
#> 5         5  -271.7336   18.65296 2.1001220 4.065978
#> 6         6  -254.0618   17.83778 3.0615865 3.791049
```

## Available Solvers

| Factory                                                                                              | Method                           | Best For                             |
|------------------------------------------------------------------------------------------------------|----------------------------------|--------------------------------------|
| [`gradient_ascent()`](https://queelius.github.io/compositional.mle/reference/gradient_ascent.md)     | Steepest ascent with line search | General purpose, smooth likelihoods  |
| [`newton_raphson()`](https://queelius.github.io/compositional.mle/reference/newton_raphson.md)       | Second-order Newton              | Fast convergence near optimum        |
| [`bfgs()`](https://queelius.github.io/compositional.mle/reference/bfgs.md)                           | Quasi-Newton BFGS                | Good balance of speed/robustness     |
| [`lbfgsb()`](https://queelius.github.io/compositional.mle/reference/lbfgsb.md)                       | L-BFGS-B with box constraints    | High-dimensional, bounded parameters |
| [`nelder_mead()`](https://queelius.github.io/compositional.mle/reference/nelder_mead.md)             | Simplex (derivative-free)        | Non-smooth or noisy likelihoods      |
| [`sim_anneal()`](https://queelius.github.io/compositional.mle/reference/sim_anneal.md)               | Simulated annealing              | Global optimization, multi-modal     |
| [`coordinate_ascent()`](https://queelius.github.io/compositional.mle/reference/coordinate_ascent.md) | One parameter at a time          | Different parameter scales           |
| [`grid_search()`](https://queelius.github.io/compositional.mle/reference/grid_search.md)             | Exhaustive grid                  | Finding starting points              |
| [`random_search()`](https://queelius.github.io/compositional.mle/reference/random_search.md)         | Random sampling                  | High-dimensional exploration         |

## Function Transformers

``` r
# Stochastic gradient (mini-batching for large data)
loglike_sgd <- with_subsampling(loglike, data = x, subsample_size = 32)

# Regularization
loglike_l2 <- with_penalty(loglike, penalty_l2(), lambda = 0.1)
loglike_l1 <- with_penalty(loglike, penalty_l1(), lambda = 0.1)
```

## Documentation

- Full documentation: <https://queelius.github.io/compositional.mle/>
- Vignettes:
  - [Getting
    Started](https://queelius.github.io/compositional.mle/articles/getting-started.html)
  - [Case
    Studies](https://queelius.github.io/compositional.mle/articles/case-studies.html)
  - [Theory and
    Intuition](https://queelius.github.io/compositional.mle/articles/theory-and-intuition.html)

## License

MIT

# Package index

## Problem Specification

Define the statistical estimation problem

- [`mle_problem()`](https://queelius.github.io/compositional.mle/reference/mle_problem.md)
  : Create an MLE Problem Specification
- [`update(`*`<mle_problem>`*`)`](https://queelius.github.io/compositional.mle/reference/update.mle_problem.md)
  : Update an mle_problem
- [`is_mle_problem()`](https://queelius.github.io/compositional.mle/reference/is_mle_problem.md)
  : Check if object is an mle_problem
- [`get_score()`](https://queelius.github.io/compositional.mle/reference/get_score.md)
  : Get score function from problem
- [`get_fisher()`](https://queelius.github.io/compositional.mle/reference/get_fisher.md)
  : Get Fisher information function from problem
- [`clear_cache()`](https://queelius.github.io/compositional.mle/reference/clear_cache.md)
  : Clear derivative cache
- [`mle_constraint()`](https://queelius.github.io/compositional.mle/reference/mle_constraint.md)
  : Create domain constraint specification
- [`is_mle_constraint()`](https://queelius.github.io/compositional.mle/reference/is_mle_constraint.md)
  : Check if object is an mle_constraint

## Solver Factories

Create solver functions

- [`gradient_ascent()`](https://queelius.github.io/compositional.mle/reference/gradient_ascent.md)
  : Gradient Ascent Solver
- [`newton_raphson()`](https://queelius.github.io/compositional.mle/reference/newton_raphson.md)
  : Newton-Raphson Solver
- [`fisher_scoring()`](https://queelius.github.io/compositional.mle/reference/fisher_scoring.md)
  : Fisher Scoring Solver
- [`bfgs()`](https://queelius.github.io/compositional.mle/reference/bfgs.md)
  : BFGS Solver
- [`lbfgsb()`](https://queelius.github.io/compositional.mle/reference/lbfgsb.md)
  : L-BFGS-B Solver (Box Constrained)
- [`nelder_mead()`](https://queelius.github.io/compositional.mle/reference/nelder_mead.md)
  : Nelder-Mead Solver (Derivative-Free)
- [`grid_search()`](https://queelius.github.io/compositional.mle/reference/grid_search.md)
  : Grid Search Solver
- [`random_search()`](https://queelius.github.io/compositional.mle/reference/random_search.md)
  : Random Search Solver
- [`sim_anneal()`](https://queelius.github.io/compositional.mle/reference/sim_anneal.md)
  : Simulated Annealing Solver
- [`coordinate_ascent()`](https://queelius.github.io/compositional.mle/reference/coordinate_ascent.md)
  : Coordinate Ascent Solver

## Composition Operators

Combine solvers into strategies

- [`compose()`](https://queelius.github.io/compositional.mle/reference/compose.md)
  : Compose Multiple Solvers Sequentially
- [`chain()`](https://queelius.github.io/compositional.mle/reference/chain.md)
  : Chain Solvers with Early Stopping
- [`race()`](https://queelius.github.io/compositional.mle/reference/race.md)
  : Race Multiple Solvers
- [`` `%>>%` ``](https://queelius.github.io/compositional.mle/reference/grapes-greater-than-greater-than-grapes.md)
  : Sequential Solver Composition
- [`` `%|%` ``](https://queelius.github.io/compositional.mle/reference/race_operator.md)
  : Parallel Solver Racing (Operator)
- [`with_restarts()`](https://queelius.github.io/compositional.mle/reference/with_restarts.md)
  : Multiple Random Restarts
- [`unless_converged()`](https://queelius.github.io/compositional.mle/reference/unless_converged.md)
  : Conditional Refinement

## Samplers

Starting point generators for restarts

- [`uniform_sampler()`](https://queelius.github.io/compositional.mle/reference/uniform_sampler.md)
  : Uniform Sampler Factory
- [`normal_sampler()`](https://queelius.github.io/compositional.mle/reference/normal_sampler.md)
  : Normal Sampler Factory

## Function Transformers

Transform log-likelihood functions

- [`with_subsampling()`](https://queelius.github.io/compositional.mle/reference/with_subsampling.md)
  : Create stochastic log-likelihood with subsampling
- [`with_penalty()`](https://queelius.github.io/compositional.mle/reference/with_penalty.md)
  : Add penalty term to log-likelihood
- [`penalty_l1()`](https://queelius.github.io/compositional.mle/reference/penalty_l1.md)
  : L1 penalty function (LASSO)
- [`penalty_l2()`](https://queelius.github.io/compositional.mle/reference/penalty_l2.md)
  : L2 penalty function (Ridge)
- [`penalty_elastic_net()`](https://queelius.github.io/compositional.mle/reference/penalty_elastic_net.md)
  : Elastic net penalty (combination of L1 and L2)
- [`compose_transforms()`](https://queelius.github.io/compositional.mle/reference/compose_transforms.md)
  : Compose Multiple Function Transformations

## Configuration

Type-safe configuration objects

- [`mle_config()`](https://queelius.github.io/compositional.mle/reference/mle_config.md)
  : Create optimization configuration
- [`mle_config_gradient()`](https://queelius.github.io/compositional.mle/reference/mle_config_gradient.md)
  : Create gradient-based optimization configuration
- [`mle_config_linesearch()`](https://queelius.github.io/compositional.mle/reference/mle_config_linesearch.md)
  : Create line search configuration
- [`is_mle_config()`](https://queelius.github.io/compositional.mle/reference/is_mle_config.md)
  : Check if object is an mle_config

## Tracing

Track optimization progress

- [`mle_trace()`](https://queelius.github.io/compositional.mle/reference/mle_trace.md)
  : Create a Trace Configuration
- [`is_tracing()`](https://queelius.github.io/compositional.mle/reference/is_tracing.md)
  : Check if tracing is enabled

## Results & Visualization

Work with and visualize optimization results

- [`is_converged()`](https://queelius.github.io/compositional.mle/reference/is_converged.md)
  : Check if solver converged
- [`is_mle_numerical()`](https://queelius.github.io/compositional.mle/reference/is_mle_numerical.md)
  : Check if object is an mle_numerical
- [`num_iterations()`](https://queelius.github.io/compositional.mle/reference/num_iterations.md)
  : Get number of iterations
- [`optimization_path()`](https://queelius.github.io/compositional.mle/reference/optimization_path.md)
  : Extract Optimization Path as Data Frame
- [`plot(`*`<mle_numerical>`*`)`](https://queelius.github.io/compositional.mle/reference/plot.mle_numerical.md)
  : Plot Optimization Convergence
- [`plot(`*`<mle_trace_data>`*`)`](https://queelius.github.io/compositional.mle/reference/plot.mle_trace_data.md)
  : Plot Trace Data Directly

# Articles

### Getting Started

- [Getting Started with
  compositional.mle](https://queelius.github.io/compositional.mle/articles/getting-started.md):

### Understanding MLE

- [Theory and Intuition Behind Numerical
  MLE](https://queelius.github.io/compositional.mle/articles/theory-and-intuition.md):
- [Case Studies: MLE for Common
  Distributions](https://queelius.github.io/compositional.mle/articles/case-studies.md):

### Advanced Topics

- [Designing Optimization
  Strategies](https://queelius.github.io/compositional.mle/articles/strategy-design.md):
- [The MLE
  Ecosystem](https://queelius.github.io/compositional.mle/articles/mle-ecosystem.md):
