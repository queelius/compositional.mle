[{"path":[]},{"path":"https://queelius.github.io/compositional.mle/AGENTS.html","id":"project-structure--module-organization","dir":"","previous_headings":"","what":"Project Structure & Module Organization","title":"Repository Guidelines","text":"Package source lives R/ (solvers, composition operators, tracing, configuration). Keep new APIs exported via roxygen comments (@export) rely devtools::document() refresh NAMESPACE man/. Tests tests/testthat/; prefer test-<topic>.R files mirror module names (e.g., test-solvers.R, test-transformers.R). Documentation sources: README.Rmd (rendered README.md), vignettes vignettes/, pkgdown site output docs/ driven _pkgdown.yml. Additional references: DESIGN.md architecture context TESTING_SUMMARY.md historical coverage notes.","code":""},{"path":"https://queelius.github.io/compositional.mle/AGENTS.html","id":"build-test-and-development-commands","dir":"","previous_headings":"","what":"Build, Test, and Development Commands","title":"Repository Guidelines","text":"Load package interactive dev: R -q -e \"devtools::load_all()\". Run unit + integration tests: R -q -e \"devtools::test()\" (uses tests/testthat). Full check PRs: Regenerate docs API changes: R -q -e \"devtools::document()\". Rebuild site docs change: R -q -e \"pkgdown::build_site()\".","code":"R CMD build . R CMD check --as-cran compositional.mle_*.tar.gz"},{"path":"https://queelius.github.io/compositional.mle/AGENTS.html","id":"coding-style--naming-conventions","dir":"","previous_headings":"","what":"Coding Style & Naming Conventions","title":"Repository Guidelines","text":"Use base R style 2-space indents, tabs. Keep line length reasonable (~100 chars) prefer explicit argument names. Functions variables use snake_case; operators stay descriptive (%>>%, %|%, with_restarts()). Validate inputs early stopifnot()/stop(), keep solver outputs consistent (theta.hat, loglike, trace). Write roxygen comments exported functions, including examples set seeds reproducibility.","code":""},{"path":"https://queelius.github.io/compositional.mle/AGENTS.html","id":"testing-guidelines","dir":"","previous_headings":"","what":"Testing Guidelines","title":"Repository Guidelines","text":"Framework: testthat (edition 3). Name tests behavior test, grouping module. Use deterministic seeds small synthetic data avoid flaky convergence. Quick targeted run: R -q -e \"testthat::test_file('tests/testthat/test-solvers.R')\". adding solvers, include unit coverage constraints, tracing, failure modes; add integration paths test-integration.R appropriate.","code":""},{"path":"https://queelius.github.io/compositional.mle/AGENTS.html","id":"commit--pull-request-guidelines","dir":"","previous_headings":"","what":"Commit & Pull Request Guidelines","title":"Repository Guidelines","text":"Commit messages follow short, imperative summaries (e.g., Add Remotes field algebraic.mle dependency). Squash fixup noise locally. PRs describe change, note new commands tuning flags, list tests executed. Link related issues include output snippets convergence tuning changes behavior. Avoid committing generated artifacts unless intentional (docs/ pkgdown output versioned); never edit README.md directly—update README.Rmd.","code":""},{"path":"https://queelius.github.io/compositional.mle/CLAUDE.html","id":null,"dir":"","previous_headings":"","what":"CLAUDE.md","title":"CLAUDE.md","text":"file provides guidance Claude Code (claude.ai/code) working code repository.","code":""},{"path":"https://queelius.github.io/compositional.mle/CLAUDE.html","id":"package-overview","dir":"","previous_headings":"","what":"Package Overview","title":"CLAUDE.md","text":"compositional.mle R package composable maximum likelihood estimation. Solvers first-class functions combine via operators: sequential chaining (%>>%), parallel racing (%|%), random restarts (with_restarts). design follows SICP principles combining solvers yields solver (closure property). Key dependency: algebraic.mle provides base mle class results.","code":""},{"path":"https://queelius.github.io/compositional.mle/CLAUDE.html","id":"development-commands","dir":"","previous_headings":"","what":"Development Commands","title":"CLAUDE.md","text":"","code":"# Load for development devtools::load_all()  # Run all tests devtools::test()  # Run specific test file testthat::test_file(\"tests/testthat/test-solvers.R\")  # Generate documentation (roxygen2) devtools::document()  # Full package check devtools::check()  # Test coverage analysis covr::package_coverage()  # Build pkgdown site pkgdown::build_site()"},{"path":[]},{"path":"https://queelius.github.io/compositional.mle/CLAUDE.html","id":"core-design-pattern","dir":"","previous_headings":"Architecture","what":"Core Design Pattern","title":"CLAUDE.md","text":"Solvers factory functions return solver functions uniform signature: enables composition:","code":"(problem, theta0, trace) -> mle_result # Coarse-to-fine: grid -> gradient -> Newton strategy <- grid_search(n = 5) %>>% gradient_ascent() %>>% newton_raphson()  # Race different methods, pick best strategy <- gradient_ascent() %|% bfgs() %|% nelder_mead()  # Multiple random restarts strategy <- gradient_ascent() %>% with_restarts(n = 20, sampler = uniform_sampler(lower, upper))"},{"path":[]},{"path":[]},{"path":"https://queelius.github.io/compositional.mle/CLAUDE.html","id":"result-objects","dir":"","previous_headings":"Architecture","what":"Result Objects","title":"CLAUDE.md","text":"solvers return mle_numerical objects (extending algebraic.mle::mle) : - $theta.hat - MLE estimate - $loglike - log-likelihood MLE - $converged - convergence flag - $iterations - iteration count - $solver - solver name - $trace_data - optimization trace (tracing enabled)","code":""},{"path":"https://queelius.github.io/compositional.mle/CLAUDE.html","id":"typical-workflow","dir":"","previous_headings":"","what":"Typical Workflow","title":"CLAUDE.md","text":"","code":"# 1. Define the problem problem <- mle_problem(   loglike = function(theta) sum(dnorm(data, theta[1], theta[2], log = TRUE)),   score = function(theta) {...},  # Optional, computed numerically if NULL   constraint = mle_constraint(     support = function(theta) theta[2] > 0,     project = function(theta) c(theta[1], max(theta[2], 1e-8))   ) )  # 2. Create solver strategy solver <- gradient_ascent() %>>% newton_raphson()  # 3. Solve result <- solver(problem, theta0 = c(0, 1))"},{"path":"https://queelius.github.io/compositional.mle/CLAUDE.html","id":"testing-notes","dir":"","previous_headings":"","what":"Testing Notes","title":"CLAUDE.md","text":"Tests tests/testthat/ test files major component Standard normal MLE used canonical test case Solvers tested convergence known true values tolerance Tests depend algebraic.mle installed","code":""},{"path":"https://queelius.github.io/compositional.mle/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2022 algebraic.mle authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://queelius.github.io/compositional.mle/articles/case-studies.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Case Studies: MLE for Common Distributions","text":"vignette demonstrates using compositional.mle fit various probability distributions data. case study shows: Problem definition mle_problem() Composable solver strategies Comparison analytical solutions","code":""},{"path":"https://queelius.github.io/compositional.mle/articles/case-studies.html","id":"case-study-1-exponential-distribution","dir":"Articles","previous_headings":"","what":"Case Study 1: Exponential Distribution","title":"Case Studies: MLE for Common Distributions","text":"exponential distribution one parameter: rate λ>0\\lambda > 0.","code":"# Generate data n <- 100 true_rate <- 2.5 x_exp <- rexp(n, rate = true_rate)  # Define the problem problem_exp <- mle_problem(   loglike = function(lambda) {     if (lambda <= 0) return(-Inf)     n * log(lambda) - lambda * sum(x_exp)   },   score = function(lambda) n / lambda - sum(x_exp),   constraint = mle_constraint(     support = function(lambda) lambda > 0,     project = function(lambda) max(lambda, 1e-8)   ) )  # Solve result_exp <- gradient_ascent(max_iter = 50)(problem_exp, theta0 = 1)  # Compare with analytical MLE: 1/mean(x) mle_analytical <- 1 / mean(x_exp)  cat(\"Numerical MLE:  \", round(result_exp$theta.hat, 4), \"\\n\") #> Numerical MLE:   2.2236 cat(\"Analytical MLE: \", round(mle_analytical, 4), \"\\n\") #> Analytical MLE:  2.2236 cat(\"True rate:      \", true_rate, \"\\n\") #> True rate:       2.5 lambda_grid <- seq(0.1, 5, length.out = 100) ll_values <- sapply(lambda_grid, problem_exp$loglike)  plot(lambda_grid, ll_values, type = \"l\", lwd = 2,      xlab = expression(lambda), ylab = \"Log-likelihood\",      main = \"Exponential Distribution Log-Likelihood\") abline(v = result_exp$theta.hat, col = \"red\", lwd = 2, lty = 2) abline(v = true_rate, col = \"blue\", lwd = 2, lty = 3) legend(\"topright\", c(\"MLE\", \"True\"), col = c(\"red\", \"blue\"), lty = c(2, 3), lwd = 2)"},{"path":"https://queelius.github.io/compositional.mle/articles/case-studies.html","id":"case-study-2-gamma-distribution","dir":"Articles","previous_headings":"","what":"Case Study 2: Gamma Distribution","title":"Case Studies: MLE for Common Distributions","text":"Two parameters: shape α>0\\alpha > 0 rate β>0\\beta > 0.","code":"# Generate data true_shape <- 3 true_rate <- 2 x_gamma <- rgamma(200, shape = true_shape, rate = true_rate)  # Define the problem problem_gamma <- mle_problem(   loglike = function(theta) {     alpha <- theta[1]; beta <- theta[2]     if (alpha <= 0 || beta <= 0) return(-Inf)     n <- length(x_gamma)     n * (alpha * log(beta) - lgamma(alpha)) +       (alpha - 1) * sum(log(x_gamma)) - beta * sum(x_gamma)   },   score = function(theta) {     alpha <- theta[1]; beta <- theta[2]     n <- length(x_gamma)     c(n * (log(beta) - digamma(alpha)) + sum(log(x_gamma)),       n * alpha / beta - sum(x_gamma))   },   constraint = mle_constraint(     support = function(theta) all(theta > 0),     project = function(theta) pmax(theta, 1e-6)   ),   theta_names = c(\"alpha\", \"beta\") )"},{"path":"https://queelius.github.io/compositional.mle/articles/case-studies.html","id":"composing-solvers-grid-search-gradient-ascent","dir":"Articles","previous_headings":"Case Study 2: Gamma Distribution","what":"Composing Solvers: Grid Search + Gradient Ascent","title":"Case Studies: MLE for Common Distributions","text":"","code":"# Coarse-to-fine strategy strategy <- grid_search(lower = c(0.5, 0.5), upper = c(10, 10), n = 10) %>>%   gradient_ascent(max_iter = 100)  result_gamma <- strategy(problem_gamma, theta0 = c(1, 1))  cat(\"MLE:  shape =\", round(result_gamma$theta.hat[1], 4),     \" rate =\", round(result_gamma$theta.hat[2], 4), \"\\n\") #> MLE:  shape = 2.6662  rate = 1.852 cat(\"True: shape =\", true_shape, \" rate =\", true_rate, \"\\n\") #> True: shape = 3  rate = 2 alpha_grid <- seq(1, 6, length.out = 50) beta_grid <- seq(0.5, 4, length.out = 50) ll_gamma <- outer(alpha_grid, beta_grid, function(a, b) {   mapply(function(ai, bi) problem_gamma$loglike(c(ai, bi)), a, b) })  contour(alpha_grid, beta_grid, ll_gamma, nlevels = 20,         xlab = expression(alpha ~ \"(shape)\"),         ylab = expression(beta ~ \"(rate)\"),         main = \"Gamma Distribution Log-Likelihood\") points(result_gamma$theta.hat[1], result_gamma$theta.hat[2],        pch = 19, col = \"red\", cex = 1.5) points(true_shape, true_rate, pch = 4, col = \"blue\", cex = 1.5, lwd = 2) legend(\"topright\", c(\"MLE\", \"True\"), pch = c(19, 4), col = c(\"red\", \"blue\"))"},{"path":"https://queelius.github.io/compositional.mle/articles/case-studies.html","id":"case-study-3-beta-distribution","dir":"Articles","previous_headings":"","what":"Case Study 3: Beta Distribution","title":"Case Studies: MLE for Common Distributions","text":"Shape parameters α>0\\alpha > 0 β>0\\beta > 0 data [0,1][0, 1].","code":"# Generate data true_alpha <- 2 true_beta <- 5 x_beta <- rbeta(150, shape1 = true_alpha, shape2 = true_beta)  # Define the problem problem_beta <- mle_problem(   loglike = function(theta) {     a <- theta[1]; b <- theta[2]     if (a <= 0 || b <= 0) return(-Inf)     n <- length(x_beta)     n * (lgamma(a + b) - lgamma(a) - lgamma(b)) +       (a - 1) * sum(log(x_beta)) + (b - 1) * sum(log(1 - x_beta))   },   score = function(theta) {     a <- theta[1]; b <- theta[2]     n <- length(x_beta)     psi_ab <- digamma(a + b)     c(n * (psi_ab - digamma(a)) + sum(log(x_beta)),       n * (psi_ab - digamma(b)) + sum(log(1 - x_beta)))   },   constraint = mle_constraint(     support = function(theta) all(theta > 0),     project = function(theta) pmax(theta, 1e-6)   ) )  # Method of moments for starting values m <- mean(x_beta); v <- var(x_beta) alpha_start <- m * (m * (1 - m) / v - 1) beta_start <- (1 - m) * (m * (1 - m) / v - 1)  result_beta <- gradient_ascent(max_iter = 200)(   problem_beta,   theta0 = c(max(alpha_start, 0.5), max(beta_start, 0.5)) )  cat(\"MLE:  alpha =\", round(result_beta$theta.hat[1], 4),     \" beta =\", round(result_beta$theta.hat[2], 4), \"\\n\") #> MLE:  alpha = 1.6398  beta = 4.3577 cat(\"True: alpha =\", true_alpha, \" beta =\", true_beta, \"\\n\") #> True: alpha = 2  beta = 5 hist(x_beta, breaks = 20, freq = FALSE, col = \"lightgray\",      main = \"Beta Distribution Fit\", xlab = \"x\") curve(dbeta(x, result_beta$theta.hat[1], result_beta$theta.hat[2]),       add = TRUE, col = \"red\", lwd = 2) curve(dbeta(x, true_alpha, true_beta), add = TRUE, col = \"blue\", lwd = 2, lty = 2) legend(\"topright\", c(\"Fitted\", \"True\"), col = c(\"red\", \"blue\"), lwd = 2, lty = c(1, 2))"},{"path":"https://queelius.github.io/compositional.mle/articles/case-studies.html","id":"case-study-4-weibull-distribution","dir":"Articles","previous_headings":"","what":"Case Study 4: Weibull Distribution","title":"Case Studies: MLE for Common Distributions","text":"Shape k>0k > 0 scale λ>0\\lambda > 0, using Newton-Raphson.","code":"# Generate data true_k <- 2; true_lambda <- 3 x_weibull <- rweibull(100, shape = true_k, scale = true_lambda)  # Define the problem (score only, Fisher computed numerically) problem_weibull <- mle_problem(   loglike = function(theta) {     k <- theta[1]; lambda <- theta[2]     if (k <= 0 || lambda <= 0) return(-Inf)     n <- length(x_weibull)     n * log(k) - n * k * log(lambda) +       (k - 1) * sum(log(x_weibull)) - sum((x_weibull / lambda)^k)   },   score = function(theta) {     k <- theta[1]; lambda <- theta[2]     n <- length(x_weibull)     x_scaled <- x_weibull / lambda     x_scaled_k <- x_scaled^k     c(n / k - n * log(lambda) + sum(log(x_weibull)) - sum(x_scaled_k * log(x_scaled)),       -n * k / lambda + k * sum(x_scaled_k) / lambda)   },   constraint = mle_constraint(     support = function(theta) all(theta > 0),     project = function(theta) pmax(theta, 1e-6)   ) )  # Newton-Raphson with numerical Fisher result_weibull <- newton_raphson(max_iter = 50)(problem_weibull, theta0 = c(1, 1))  cat(\"MLE:  shape =\", round(result_weibull$theta.hat[1], 4),     \" scale =\", round(result_weibull$theta.hat[2], 4), \"\\n\") #> MLE:  shape = 2.0466  scale = 2.8588 cat(\"True: shape =\", true_k, \" scale =\", true_lambda, \"\\n\") #> True: shape = 2  scale = 3 hist(x_weibull, breaks = 15, freq = FALSE, col = \"lightgray\",      main = \"Weibull Distribution Fit\", xlab = \"x\") curve(dweibull(x, shape = result_weibull$theta.hat[1],                scale = result_weibull$theta.hat[2]),       add = TRUE, col = \"red\", lwd = 2) curve(dweibull(x, shape = true_k, scale = true_lambda),       add = TRUE, col = \"blue\", lwd = 2, lty = 2) legend(\"topright\", c(\"Fitted\", \"True\"), col = c(\"red\", \"blue\"), lwd = 2, lty = c(1, 2))"},{"path":"https://queelius.github.io/compositional.mle/articles/case-studies.html","id":"case-study-5-mixture-of-normals","dir":"Articles","previous_headings":"","what":"Case Study 5: Mixture of Normals","title":"Case Studies: MLE for Common Distributions","text":"Multimodal likelihood requires good initialization restarts.","code":"# Generate mixture data n1 <- 60; n2 <- 40 x_mix <- c(rnorm(n1, mean = 0, sd = 1), rnorm(n2, mean = 4, sd = 1.5))  # Parameters: (mu1, sigma1, mu2, sigma2, pi) problem_mix <- mle_problem(   loglike = function(theta) {     mu1 <- theta[1]; s1 <- theta[2]     mu2 <- theta[3]; s2 <- theta[4]     pi1 <- theta[5]     if (s1 <= 0 || s2 <= 0 || pi1 <= 0 || pi1 >= 1) return(-Inf)     # Log-sum-exp for numerical stability     log_p1 <- log(pi1) + dnorm(x_mix, mu1, s1, log = TRUE)     log_p2 <- log(1 - pi1) + dnorm(x_mix, mu2, s2, log = TRUE)     log_max <- pmax(log_p1, log_p2)     sum(log_max + log(exp(log_p1 - log_max) + exp(log_p2 - log_max)))   },   constraint = mle_constraint(     support = function(theta) theta[2] > 0 && theta[4] > 0 && theta[5] > 0 && theta[5] < 1,     project = function(theta) c(theta[1], max(theta[2], 0.1), theta[3],                                  max(theta[4], 0.1), min(max(theta[5], 0.01), 0.99))   ) )  # Use k-means for initialization km <- kmeans(x_mix, centers = 2) mu1_init <- min(km$centers); mu2_init <- max(km$centers) s1_init <- sd(x_mix[km$cluster == which.min(km$centers)]) s2_init <- sd(x_mix[km$cluster == which.max(km$centers)]) pi_init <- mean(km$cluster == which.min(km$centers))  result_mix <- gradient_ascent(learning_rate = 0.5, max_iter = 300)(   problem_mix,   theta0 = c(mu1_init, s1_init, mu2_init, s2_init, pi_init) )  cat(\"Fitted:\\n\") #> Fitted: cat(\"  Component 1: mu =\", round(result_mix$theta.hat[1], 2),     \" sigma =\", round(result_mix$theta.hat[2], 2), \"\\n\") #>   Component 1: mu = -0.13  sigma = 0.9 cat(\"  Component 2: mu =\", round(result_mix$theta.hat[3], 2),     \" sigma =\", round(result_mix$theta.hat[4], 2), \"\\n\") #>   Component 2: mu = 4.18  sigma = 1.53 cat(\"  Mixing proportion:\", round(result_mix$theta.hat[5], 2), \"\\n\") #>   Mixing proportion: 0.58 hist(x_mix, breaks = 25, freq = FALSE, col = \"lightgray\",      main = \"Gaussian Mixture Fit\", xlab = \"x\")  x_seq <- seq(min(x_mix) - 1, max(x_mix) + 1, length.out = 200) fitted_density <- result_mix$theta.hat[5] *   dnorm(x_seq, result_mix$theta.hat[1], result_mix$theta.hat[2]) +   (1 - result_mix$theta.hat[5]) *   dnorm(x_seq, result_mix$theta.hat[3], result_mix$theta.hat[4]) lines(x_seq, fitted_density, col = \"red\", lwd = 2)  true_density <- (n1/(n1+n2)) * dnorm(x_seq, 0, 1) + (n2/(n1+n2)) * dnorm(x_seq, 4, 1.5) lines(x_seq, true_density, col = \"blue\", lwd = 2, lty = 2) legend(\"topright\", c(\"Fitted\", \"True\"), col = c(\"red\", \"blue\"), lwd = 2, lty = c(1, 2))"},{"path":"https://queelius.github.io/compositional.mle/articles/case-studies.html","id":"summary","dir":"Articles","previous_headings":"","what":"Summary","title":"Case Studies: MLE for Common Distributions","text":"Key takeaways: Separate problem solver - mle_problem() encapsulates model Compose strategies - Use %>>% coarse--fine optimization Use constraints - Keep parameters valid ranges Good initialization - Critical multimodal problems","code":""},{"path":"https://queelius.github.io/compositional.mle/articles/getting-started.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Getting Started with compositional.mle","text":"compositional.mle package provides composable optimization strategies maximum likelihood estimation (MLE). Following SICP principles, offers: Primitive solvers - gradient_ascent(), newton_raphson(), bfgs(), nelder_mead(), etc. Composition operators - %>>% (sequential), %|% (race), with_restarts() Closure property - Combining solvers yields solver","code":""},{"path":"https://queelius.github.io/compositional.mle/articles/getting-started.html","id":"installation","dir":"Articles","previous_headings":"","what":"Installation","title":"Getting Started with compositional.mle","text":"","code":"devtools::install_github(\"queelius/compositional.mle\") library(compositional.mle)"},{"path":"https://queelius.github.io/compositional.mle/articles/getting-started.html","id":"quick-start-normal-distribution-mle","dir":"Articles","previous_headings":"","what":"Quick Start: Normal Distribution MLE","title":"Getting Started with compositional.mle","text":"","code":"# Generate sample data set.seed(123) data <- rnorm(100, mean = 5, sd = 2)  # Define the problem (separate from solver strategy) problem <- mle_problem(   loglike = function(theta) {     if (theta[2] <= 0) return(-Inf)     sum(dnorm(data, theta[1], theta[2], log = TRUE))   },   score = function(theta) {     mu <- theta[1]; sigma <- theta[2]; n <- length(data)     c(sum(data - mu) / sigma^2,       -n / sigma + sum((data - mu)^2) / sigma^3)   },   constraint = mle_constraint(     support = function(theta) theta[2] > 0,     project = function(theta) c(theta[1], max(theta[2], 1e-6))   ),   theta_names = c(\"mu\", \"sigma\") )  # Solve with gradient ascent result <- gradient_ascent()(problem, theta0 = c(0, 1))  cat(\"Estimated mean:\", result$theta.hat[1], \"(true: 5)\\n\") #> Estimated mean: 5.180812 (true: 5) cat(\"Estimated sd:\", result$theta.hat[2], \"(true: 2)\\n\") #> Estimated sd: 1.816481 (true: 2)"},{"path":"https://queelius.github.io/compositional.mle/articles/getting-started.html","id":"the-problem-solver-separation","dir":"Articles","previous_headings":"","what":"The Problem-Solver Separation","title":"Getting Started with compositional.mle","text":"key design principle separating ’re estimating estimate :","code":"# The problem encapsulates the statistical model print(problem) #> MLE Problem #>   Parameters: mu, sigma  #>   Score: analytic  #>   Fisher: numerical  #>   Constraints: yes  # Solvers are independent strategies solver1 <- gradient_ascent(max_iter = 100) solver2 <- newton_raphson(max_iter = 50) solver3 <- bfgs()  # Same problem, different solvers result1 <- solver1(problem, c(0, 1)) result2 <- solver2(problem, c(0, 1)) result3 <- solver3(problem, c(0, 1))  cat(\"Gradient ascent:\", result1$theta.hat, \"\\n\") #> Gradient ascent: 5.180812 1.816481 cat(\"Newton-Raphson:\", result2$theta.hat, \"\\n\") #> Newton-Raphson: 0 1 cat(\"BFGS:\", result3$theta.hat, \"\\n\") #> BFGS: 100.7711 567.4039"},{"path":[]},{"path":"https://queelius.github.io/compositional.mle/articles/getting-started.html","id":"sequential-chaining","dir":"Articles","previous_headings":"Composing Solvers","what":"Sequential Chaining (%>>%)","title":"Getting Started with compositional.mle","text":"Chain solvers coarse--fine optimization:","code":"# Grid search finds a good region, then gradient ascent refines strategy <- grid_search(lower = c(-10, 0.5), upper = c(10, 5), n = 5) %>>%   gradient_ascent(max_iter = 50)  result <- strategy(problem, theta0 = c(0, 1)) cat(\"Result:\", result$theta.hat, \"\\n\") #> Result: 5.180812 1.816481"},{"path":"https://queelius.github.io/compositional.mle/articles/getting-started.html","id":"three-stage-refinement","dir":"Articles","previous_headings":"Composing Solvers","what":"Three-Stage Refinement","title":"Getting Started with compositional.mle","text":"","code":"# Coarse grid -> gradient ascent -> Newton-Raphson polish strategy <- grid_search(lower = c(-10, 0.5), upper = c(10, 5), n = 5) %>>%   gradient_ascent(max_iter = 30) %>>%   newton_raphson(max_iter = 10)  result <- strategy(problem, theta0 = c(0, 1)) cat(\"Result:\", result$theta.hat, \"\\n\") #> Result: 5.180812 1.816481 cat(\"Converged:\", result$converged, \"\\n\") #> Converged: FALSE"},{"path":"https://queelius.github.io/compositional.mle/articles/getting-started.html","id":"parallel-racing","dir":"Articles","previous_headings":"Composing Solvers","what":"Parallel Racing (%|%)","title":"Getting Started with compositional.mle","text":"Race multiple methods keep best result:","code":"# Try gradient-based and derivative-free methods strategy <- gradient_ascent() %|% bfgs() %|% nelder_mead()  result <- strategy(problem, theta0 = c(0, 1)) cat(\"Winner:\", result$solver, \"\\n\") #> Winner: gradient_ascent cat(\"Result:\", result$theta.hat, \"\\n\") #> Result: 5.180812 1.816481"},{"path":"https://queelius.github.io/compositional.mle/articles/getting-started.html","id":"random-restarts","dir":"Articles","previous_headings":"Composing Solvers","what":"Random Restarts","title":"Getting Started with compositional.mle","text":"Escape local optima multiple starting points:","code":"strategy <- with_restarts(   gradient_ascent(),   n = 10,   sampler = uniform_sampler(c(-10, 0.5), c(10, 5)) )  result <- strategy(problem, theta0 = c(0, 1)) cat(\"Best restart:\", result$best_restart, \"of\", result$n_restarts, \"\\n\") #> Best restart: 1 of 10 cat(\"Result:\", result$theta.hat, \"\\n\") #> Result: 5.180812 1.816481"},{"path":"https://queelius.github.io/compositional.mle/articles/getting-started.html","id":"conditional-refinement","dir":"Articles","previous_headings":"Composing Solvers","what":"Conditional Refinement","title":"Getting Started with compositional.mle","text":"refine first solver didn’t converge:","code":"strategy <- unless_converged(   gradient_ascent(max_iter = 10),  # Quick attempt    newton_raphson(max_iter = 50)     # Refine if needed )  result <- strategy(problem, theta0 = c(0, 1)) cat(\"Result:\", result$theta.hat, \"\\n\") #> Result: 5.180812 1.816481"},{"path":[]},{"path":"https://queelius.github.io/compositional.mle/articles/getting-started.html","id":"constraints","dir":"Articles","previous_headings":"","what":"Constraints","title":"Getting Started with compositional.mle","text":"Define domain constraints support checking projection:","code":"# Positive parameters pos_constraint <- mle_constraint(   support = function(theta) all(theta > 0),   project = function(theta) pmax(theta, 1e-8) )  # Box constraints [0, 10] box_constraint <- mle_constraint(   support = function(theta) all(theta >= 0 & theta <= 10),   project = function(theta) pmax(0, pmin(10, theta)) )  # Use in problem definition problem_constrained <- mle_problem(   loglike = function(theta) -sum((theta - 5)^2),   constraint = pos_constraint )"},{"path":[]},{"path":"https://queelius.github.io/compositional.mle/articles/getting-started.html","id":"stochastic-gradient-mini-batching","dir":"Articles","previous_headings":"Function Transformers","what":"Stochastic Gradient (Mini-batching)","title":"Getting Started with compositional.mle","text":"large datasets, subsample observations:","code":"# Original log-likelihood uses all data loglike_full <- function(theta, obs = large_data) {   sum(dnorm(obs, theta[1], theta[2], log = TRUE)) }  # Stochastic version uses random subsets loglike_sgd <- with_subsampling(loglike_full, data = large_data, subsample_size = 100)"},{"path":"https://queelius.github.io/compositional.mle/articles/getting-started.html","id":"regularization","dir":"Articles","previous_headings":"Function Transformers","what":"Regularization","title":"Getting Started with compositional.mle","text":"Add penalty terms regularization:","code":"loglike <- function(theta) -sum(theta^2)  # L1 (Lasso), L2 (Ridge), Elastic Net loglike_l1 <- with_penalty(loglike, penalty_l1(), lambda = 0.1) loglike_l2 <- with_penalty(loglike, penalty_l2(), lambda = 0.1) loglike_enet <- with_penalty(loglike, penalty_elastic_net(alpha = 0.5), lambda = 0.1)  theta <- c(1, 2, 3) cat(\"Original:\", loglike(theta), \"\\n\") #> Original: -14 cat(\"With L1:\", loglike_l1(theta), \"\\n\") #> With L1: -14.6 cat(\"With L2:\", loglike_l2(theta), \"\\n\") #> With L2: -15.4"},{"path":"https://queelius.github.io/compositional.mle/articles/getting-started.html","id":"tracing-optimization","dir":"Articles","previous_headings":"","what":"Tracing Optimization","title":"Getting Started with compositional.mle","text":"Track optimization path diagnostics:","code":"trace_config <- mle_trace(values = TRUE, path = TRUE, gradients = TRUE)  result <- gradient_ascent(max_iter = 20)(   problem,   theta0 = c(0, 1),   trace = trace_config )  if (!is.null(result$trace_data)) {   cat(\"Iterations:\", result$trace_data$total_iterations, \"\\n\")   cat(\"Final log-likelihood:\", tail(result$trace_data$values, 1), \"\\n\") } #> Iterations: 20  #> Final log-likelihood: -201.5839"},{"path":"https://queelius.github.io/compositional.mle/articles/getting-started.html","id":"api-summary","dir":"Articles","previous_headings":"","what":"API Summary","title":"Getting Started with compositional.mle","text":"Problem Specification: - mle_problem() - Define estimation problem - mle_constraint() - Domain constraints Solver Factories: - gradient_ascent(), newton_raphson(), bfgs(), lbfgsb(), nelder_mead() - grid_search(), random_search() Composition: - %>>% - Sequential chaining - %|% - Parallel racing - with_restarts() - Multiple starting points - unless_converged() - Conditional refinement - compose() - Compose multiple solvers Samplers: - uniform_sampler(), normal_sampler() Transformers: - with_subsampling(), with_penalty() - penalty_l1(), penalty_l2(), penalty_elastic_net()","code":""},{"path":"https://queelius.github.io/compositional.mle/articles/mle-ecosystem.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"The MLE Ecosystem","text":"compositional.mle part ecosystem R packages share single design principle Structure Interpretation Computer Programs (SICP): closure—result combining things kind thing, ready combined . principle appears three levels: vignette walks story. packages referenced available CRAN.","code":""},{"path":"https://queelius.github.io/compositional.mle/articles/mle-ecosystem.html","id":"composing-solvers","dir":"Articles","previous_headings":"","what":"Composing Solvers","title":"The MLE Ecosystem","text":"core idea compositional.mle solvers first-class functions compose via operators: %>>% (sequential chaining) — pipe result one solver next %|% (parallel racing) — run solvers simultaneously, keep best with_restarts() — retry solver multiple starting points operator returns solver, can compose freely: can race different approaches let best log-likelihood win: combine restarts chaining: See vignette(\"strategy-design\") thorough treatment solver composition.","code":"library(compositional.mle)  # Generate data set.seed(42) y <- rnorm(200, mean = 5, sd = 2)  # Define the log-likelihood (numDeriv handles derivatives by default) ll <- function(theta) {   mu <- theta[1]; sigma <- theta[2]   -length(y) * log(sigma) - 0.5 * sum((y - mu)^2) / sigma^2 }  problem <- mle_problem(loglike = ll)  # Coarse-to-fine: grid search for a starting region, then L-BFGS-B strategy <- grid_search(lower = c(0, 0.5), upper = c(10, 5), n = 5) %>>%   lbfgsb(lower = c(-Inf, 1e-4), upper = c(Inf, Inf))  result <- strategy(problem, theta0 = c(0, 1)) result #> MLE Solver Result #> ----------------- #> Method:     grid -> lbfgsb #> Converged:  TRUE #> Iterations: 10 #> Log-likelihood: -424.84 #> #> Estimate: #> [1] 5.0609 1.9498 race <- bfgs() %|% nelder_mead() %|% gradient_ascent() result_race <- race(problem, theta0 = c(0, 1)) robust <- with_restarts(   gradient_ascent() %>>% bfgs(),   n = 10,   sampler = uniform_sampler(lower = c(-10, 0.1), upper = c(10, 10)) ) result_robust <- robust(problem, theta0 = c(0, 1))"},{"path":"https://queelius.github.io/compositional.mle/articles/mle-ecosystem.html","id":"the-mle-result-object","dir":"Articles","previous_headings":"","what":"The mle Result Object","title":"The MLE Ecosystem","text":"Every solver returns mle object (defined algebraic.mle). shared currency ecosystem—package produces consumes mle objects works every package. mle class provides uniform interface: key point: results solver interface. Whether used Newton-Raphson, grid search, composed pipeline, params(), se(), confint() work way.","code":"library(algebraic.mle)  # Extract estimates and uncertainty params(result)       # parameter estimates (theta-hat) se(result)           # standard errors vcov(result)         # variance-covariance matrix loglik_val(result)   # log-likelihood at the MLE confint(result)      # 95% confidence intervals #> params(result) #> [1] 5.0609 1.9498 #> #> se(result) #> [1] 0.1379 0.0975 #> #> vcov(result) #>              [,1]         [,2] #> [1,]  0.019009 -0.000007 #> [2,] -0.000007  0.009506 #> #> loglik_val(result) #> [1] -424.84 #> #> confint(result) #>          2.5 %   97.5 % #> [1,] 4.7906  5.3312 #> [2,] 1.7587  2.1410"},{"path":"https://queelius.github.io/compositional.mle/articles/mle-ecosystem.html","id":"combining-independent-mles","dir":"Articles","previous_headings":"","what":"Combining Independent MLEs","title":"The MLE Ecosystem","text":"Suppose three independent labs estimate mean Normal(μ,σ)(\\mu, \\sigma) population data. produces mle object. algebraic.mle provides mle_weighted() combine via inverse-variance weighting using Fisher information: combined estimate smaller standard error individual estimate—power information pooling. mle_weighted() returns mle object, can pass function accepts MLEs: confint(), se(), weighting, hypothesis testing. Combining MLEs yields MLE (closure).","code":"# Three independent datasets from the same population set.seed(123) y1 <- rnorm(50,  mean = 10, sd = 3) y2 <- rnorm(100, mean = 10, sd = 3) y3 <- rnorm(75,  mean = 10, sd = 3)  # Fit each independently make_problem <- function(data) {   mle_problem(loglike = function(theta) {     mu <- theta[1]; sigma <- theta[2]     -length(data) * log(sigma) - 0.5 * sum((data - mu)^2) / sigma^2   }) }  solver <- lbfgsb(lower = c(-Inf, 1e-4), upper = c(Inf, Inf))  fit1 <- solver(make_problem(y1), theta0 = c(0, 1)) fit2 <- solver(make_problem(y2), theta0 = c(0, 1)) fit3 <- solver(make_problem(y3), theta0 = c(0, 1))  # Combine: inverse-variance weighting via Fisher information combined <- mle_weighted(list(fit1, fit2, fit3)) # Individual SEs vs combined data.frame(   Source   = c(\"Lab 1 (n=50)\", \"Lab 2 (n=100)\", \"Lab 3 (n=75)\", \"Combined\"),   Estimate = c(params(fit1)[1], params(fit2)[1],                params(fit3)[1], params(combined)[1]),   SE       = c(se(fit1)[1], se(fit2)[1], se(fit3)[1], se(combined)[1]) ) #>            Source Estimate     SE #> 1  Lab 1 (n=50)   10.207 0.4243 #> 2 Lab 2 (n=100)    9.869 0.2998 #> 3  Lab 3 (n=75)    9.753 0.3464 #> 4      Combined    9.934 0.1995"},{"path":"https://queelius.github.io/compositional.mle/articles/mle-ecosystem.html","id":"hypothesis-testing-with-hypothesize","dir":"Articles","previous_headings":"","what":"Hypothesis Testing with hypothesize","title":"The MLE Ecosystem","text":"hypothesize package provides composable hypothesis tests. Like solvers estimates, combining tests yields test.","code":""},{"path":"https://queelius.github.io/compositional.mle/articles/mle-ecosystem.html","id":"creating-tests-from-mle-results","dir":"Articles","previous_headings":"Hypothesis Testing with hypothesize","what":"Creating tests from MLE results","title":"The MLE Ecosystem","text":"wald_test() tests whether single parameter equals hypothesised value. lrt() compares nested models via likelihood ratio:","code":"library(hypothesize)  # Wald test: is mu = 10? w <- wald_test(estimate = params(combined)[1],                se = se(combined)[1],                null_value = 10) w #> Hypothesis test ( wald_test ) #> ----------------------------- #> Test statistic: 0.1094 #> P-value:       0.7409 #> Degrees of freedom: 1 #> Significant at 5% level: FALSE # Likelihood ratio test: does sigma differ from 3? # Compare full model (mu, sigma free) vs restricted (mu free, sigma = 3) ll_full <- loglik_val(fit2)  # full model log-likelihood ll_null <- sum(dnorm(y2, mean = params(fit2)[1], sd = 3, log = TRUE))  lr <- lrt(null_loglik = ll_null, alt_loglik = ll_full, dof = 1) lr #> Hypothesis test ( likelihood_ratio_test ) #> ------------------------------------------ #> Test statistic: 0.2851 #> P-value:       0.5934 #> Degrees of freedom: 1 #> Significant at 5% level: FALSE"},{"path":"https://queelius.github.io/compositional.mle/articles/mle-ecosystem.html","id":"combining-independent-tests","dir":"Articles","previous_headings":"Hypothesis Testing with hypothesize","what":"Combining independent tests","title":"The MLE Ecosystem","text":"independent tests (e.g., lab tests H0:μ=10H_0: \\mu = 10), fisher_combine() merges using Fisher’s method: combined test hypothesis_test object—can extract pval(), check is_significant_at(), combine . closure property work.","code":"# Each lab tests H0: mu = 10 w1 <- wald_test(params(fit1)[1], se(fit1)[1], null_value = 10) w2 <- wald_test(params(fit2)[1], se(fit2)[1], null_value = 10) w3 <- wald_test(params(fit3)[1], se(fit3)[1], null_value = 10)  # Combine independent tests combined_test <- fisher_combine(w1, w2, w3) combined_test #> Hypothesis test ( fisher_combined_test ) #> ----------------------------------------- #> Test statistic: 3.4287 #> P-value:       0.7534 #> Degrees of freedom: 6 #> Significant at 5% level: FALSE # Multiple testing correction adjusted <- adjust_pval(list(w1, w2, w3), method = \"BH\")"},{"path":"https://queelius.github.io/compositional.mle/articles/mle-ecosystem.html","id":"the-testing-interface","dir":"Articles","previous_headings":"Hypothesis Testing with hypothesize","what":"The testing interface","title":"The MLE Ecosystem","text":"hypothesis_test objects share uniform interface, mirroring mle objects share params() / se():","code":"pval(w)                    # extract p-value test_stat(w)               # extract test statistic dof(w)                     # degrees of freedom is_significant_at(w, 0.05) # check significance at alpha = 0.05 confint(w)                 # confidence interval (for Wald tests)"},{"path":"https://queelius.github.io/compositional.mle/articles/mle-ecosystem.html","id":"automatic-differentiation","dir":"Articles","previous_headings":"","what":"Automatic Differentiation","title":"The MLE Ecosystem","text":"Derivatives pluggable mle_problem(). solver never knows (cares) come : strategy trade-offs: general recommendation: start default (explicit derivatives) model development, switch AD package hand-coded derivatives need accuracy performance. derivative-free problems, use nelder_mead().","code":"# Strategy 1: numDeriv (default) --- zero effort p1 <- mle_problem(loglike = ll)  # Strategy 2: hand-coded analytic derivatives p2 <- mle_problem(   loglike = ll,   score = function(theta) {     mu <- theta[1]; sigma <- theta[2]; n <- length(y)     c(sum(y - mu) / sigma^2,       -n / sigma + sum((y - mu)^2) / sigma^3)   },   fisher = function(theta) {     n <- length(y); sigma <- theta[2]     matrix(c(n / sigma^2, 0, 0, 2 * n / sigma^2), 2, 2)   } )  # Strategy 3: automatic differentiation # Any AD package that provides score(f, theta) and hessian(f, theta) # can be plugged in here, e.g.: # p3 <- mle_problem( #   loglike = ll, #   score   = function(theta) ad_pkg::score(ll, theta), #   fisher  = function(theta) ad_pkg::hessian(ll, theta) # )"},{"path":"https://queelius.github.io/compositional.mle/articles/mle-ecosystem.html","id":"the-ecosystem-at-a-glance","dir":"Articles","previous_headings":"","what":"The Ecosystem at a Glance","title":"The MLE Ecosystem","text":"packages form pipeline: define model, solve MLE, combine estimates, test hypotheses—closure every level. typical workflow: Define model log-likelihood pass mle_problem() Solve composed solver strategy compositional.mle — get mle object Combine independent estimates mle_weighted() algebraic.mle — get (better) mle object Test hypotheses hypothesize — get hypothesis_test object Combine tests fisher_combine() — get (stronger) hypothesis_test object every step, result type input. SICP closure property, makes ecosystem composable.","code":""},{"path":"https://queelius.github.io/compositional.mle/articles/strategy-design.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Designing Optimization Strategies","text":"vignette shows design effective optimization strategies composing solvers. ’ll cover: Diagnosing convergence problems Building robust pipelines Benchmarking solver combinations Handling common failure modes","code":""},{"path":"https://queelius.github.io/compositional.mle/articles/strategy-design.html","id":"the-problem-why-composition","dir":"Articles","previous_headings":"","what":"The Problem: Why Composition?","title":"Designing Optimization Strategies","text":"Consider fitting mixture normals - notoriously multi-modal problem:","code":"# Generate mixture data x_mix <- c(rnorm(70, mean = 0, sd = 1), rnorm(30, mean = 5, sd = 1.5))  # Log-likelihood for 2-component Gaussian mixture mixture_loglike <- function(theta) {   mu1 <- theta[1]; s1 <- theta[2]   mu2 <- theta[3]; s2 <- theta[4]   pi1 <- theta[5]    if (s1 <= 0 || s2 <= 0 || pi1 <= 0 || pi1 >= 1) return(-Inf)    # Log-sum-exp for numerical stability   log_p1 <- log(pi1) + dnorm(x_mix, mu1, s1, log = TRUE)   log_p2 <- log(1 - pi1) + dnorm(x_mix, mu2, s2, log = TRUE)   log_max <- pmax(log_p1, log_p2)   sum(log_max + log(exp(log_p1 - log_max) + exp(log_p2 - log_max))) }  problem_mix <- mle_problem(   loglike = mixture_loglike,   constraint = mle_constraint(     support = function(theta) theta[2] > 0 && theta[4] > 0 &&                               theta[5] > 0 && theta[5] < 1,     project = function(theta) c(theta[1], max(theta[2], 0.1), theta[3],                                 max(theta[4], 0.1), min(max(theta[5], 0.01), 0.99))   ) )"},{"path":"https://queelius.github.io/compositional.mle/articles/strategy-design.html","id":"single-solver-often-fails","dir":"Articles","previous_headings":"The Problem: Why Composition?","what":"Single Solver: Often Fails","title":"Designing Optimization Strategies","text":"result depends heavily starting point, often get stuck local optima.","code":"# Random starting point theta0 <- c(-2, 1, 3, 1, 0.5)  result_simple <- gradient_ascent(max_iter = 100)(problem_mix, theta0)  cat(\"Simple gradient ascent:\\n\") #> Simple gradient ascent: cat(\"  mu1 =\", round(result_simple$theta.hat[1], 2),     \" mu2 =\", round(result_simple$theta.hat[3], 2), \"\\n\") #>   mu1 = 0.12  mu2 = 2.66 cat(\"  Log-likelihood:\", round(result_simple$loglike, 2), \"\\n\") #>   Log-likelihood: -219.25"},{"path":"https://queelius.github.io/compositional.mle/articles/strategy-design.html","id":"strategy-1-coarse-to-fine","dir":"Articles","previous_headings":"","what":"Strategy 1: Coarse-to-Fine","title":"Designing Optimization Strategies","text":"Start rough global search, refine:","code":"# K-means for smart initialization km <- kmeans(x_mix, centers = 2) mu1_init <- min(km$centers) mu2_init <- max(km$centers) s1_init <- sd(x_mix[km$cluster == which.min(km$centers)]) s2_init <- sd(x_mix[km$cluster == which.max(km$centers)]) pi_init <- mean(km$cluster == which.min(km$centers))  theta_init <- c(mu1_init, s1_init, mu2_init, s2_init, pi_init)  # Coarse-to-fine: random search -> gradient ascent strategy <- random_search(   sampler = function() c(runif(1, -5, 10), runif(1, 0.5, 3),                          runif(1, -5, 10), runif(1, 0.5, 3),                          runif(1, 0.2, 0.8)),   n = 50 ) %>>% gradient_ascent(max_iter = 200)  result_coarse <- strategy(problem_mix, theta_init)  cat(\"Coarse-to-fine strategy:\\n\") #> Coarse-to-fine strategy: cat(\"  mu1 =\", round(result_coarse$theta.hat[1], 2),     \" mu2 =\", round(result_coarse$theta.hat[3], 2), \"\\n\") #>   mu1 = 0.08  mu2 = 4.96 cat(\"  Log-likelihood:\", round(result_coarse$loglike, 2), \"\\n\") #>   Log-likelihood: -215.73"},{"path":"https://queelius.github.io/compositional.mle/articles/strategy-design.html","id":"strategy-2-multiple-restarts","dir":"Articles","previous_headings":"","what":"Strategy 2: Multiple Restarts","title":"Designing Optimization Strategies","text":"Run gradient ascent many starting points:","code":"# Custom sampler for mixture parameters mixture_sampler <- function() {   c(runif(1, -5, 10),    # mu1     runif(1, 0.5, 3),     # sigma1     runif(1, -5, 10),     # mu2     runif(1, 0.5, 3),     # sigma2     runif(1, 0.2, 0.8))   # pi }  strategy <- with_restarts(   gradient_ascent(max_iter = 100),   n = 20,   sampler = mixture_sampler )  result_restarts <- strategy(problem_mix, theta_init)  cat(\"Random restarts (20 starts):\\n\") #> Random restarts (20 starts): cat(\"  mu1 =\", round(result_restarts$theta.hat[1], 2),     \" mu2 =\", round(result_restarts$theta.hat[3], 2), \"\\n\") #>   mu1 = 0.08  mu2 = 4.96 cat(\"  Log-likelihood:\", round(result_restarts$loglike, 2), \"\\n\") #>   Log-likelihood: -215.73 cat(\"  Best restart:\", result_restarts$best_restart, \"of\", result_restarts$n_restarts, \"\\n\") #>   Best restart: 1 of 20"},{"path":"https://queelius.github.io/compositional.mle/articles/strategy-design.html","id":"strategy-3-racing-solvers","dir":"Articles","previous_headings":"","what":"Strategy 3: Racing Solvers","title":"Designing Optimization Strategies","text":"unsure method works best, race :","code":"strategy <- gradient_ascent() %|% bfgs() %|% nelder_mead()  result_race <- strategy(problem_mix, theta_init)  cat(\"Racing strategy:\\n\") #> Racing strategy: cat(\"  Winner:\", result_race$solver, \"\\n\") #>   Winner: gradient_ascent cat(\"  mu1 =\", round(result_race$theta.hat[1], 2),     \" mu2 =\", round(result_race$theta.hat[3], 2), \"\\n\") #>   mu1 = 0.08  mu2 = 4.96 cat(\"  Log-likelihood:\", round(result_race$loglike, 2), \"\\n\") #>   Log-likelihood: -215.73"},{"path":"https://queelius.github.io/compositional.mle/articles/strategy-design.html","id":"strategy-4-global-local","dir":"Articles","previous_headings":"","what":"Strategy 4: Global + Local","title":"Designing Optimization Strategies","text":"Combine simulated annealing global exploration gradient ascent local refinement:","code":"strategy <- sim_anneal(temp_init = 10, cooling_rate = 0.95, max_iter = 500) %>>%   gradient_ascent(max_iter = 100)  result_global <- strategy(problem_mix, theta_init)  cat(\"Global + local strategy:\\n\") #> Global + local strategy: cat(\"  mu1 =\", round(result_global$theta.hat[1], 2),     \" mu2 =\", round(result_global$theta.hat[3], 2), \"\\n\") #>   mu1 = 0.08  mu2 = 4.96 cat(\"  Log-likelihood:\", round(result_global$loglike, 2), \"\\n\") #>   Log-likelihood: -215.73"},{"path":"https://queelius.github.io/compositional.mle/articles/strategy-design.html","id":"diagnosing-convergence","dir":"Articles","previous_headings":"","what":"Diagnosing Convergence","title":"Designing Optimization Strategies","text":"Use tracing understand optimization behavior:","code":"# Enable full tracing trace_cfg <- mle_trace(values = TRUE, gradients = TRUE, path = TRUE)  # Simple problem for clear visualization simple_problem <- mle_problem(   loglike = function(theta) -sum((theta - c(3, 2))^2),   score = function(theta) -2 * (theta - c(3, 2)),   constraint = mle_constraint(support = function(theta) TRUE) )  result_traced <- gradient_ascent(max_iter = 30)(   simple_problem, c(-2, -1), trace = trace_cfg )  # Visualize convergence plot(result_traced, which = c(\"loglike\", \"path\"))"},{"path":"https://queelius.github.io/compositional.mle/articles/strategy-design.html","id":"extracting-trace-data","dir":"Articles","previous_headings":"Diagnosing Convergence","what":"Extracting Trace Data","title":"Designing Optimization Strategies","text":"","code":"path_df <- optimization_path(result_traced) head(path_df) #>   iteration     loglike grad_norm    theta_1     theta_2 #> 1         1 -34.0000000 11.661904 -2.0000000 -1.00000000 #> 2         2 -23.3380962  9.661904 -1.1425071 -0.48550424 #> 3         3 -14.6761924  7.661904 -0.2850141  0.02899151 #> 4         4  -8.0142886  5.661904  0.5724788  0.54348727 #> 5         5  -3.3523848  3.661904  1.4299717  1.05798302 #> 6         6  -0.6904811  1.661904  2.2874646  1.57247878  # Check convergence rate if (nrow(path_df) > 5) {   improvement <- diff(path_df$loglike)   cat(\"\\nLog-likelihood improvement per iteration:\\n\")   print(round(improvement[1:min(5, length(improvement))], 4)) } #>  #> Log-likelihood improvement per iteration: #> [1] 10.6619  8.6619  6.6619  4.6619  2.6619"},{"path":"https://queelius.github.io/compositional.mle/articles/strategy-design.html","id":"benchmarking-strategies","dir":"Articles","previous_headings":"","what":"Benchmarking Strategies","title":"Designing Optimization Strategies","text":"Compare different strategies problem:","code":"# Test problem: bimodal likelihood bimodal <- mle_problem(   loglike = function(theta) {     log(0.3 * dnorm(theta, 2, 0.5) + 0.7 * dnorm(theta, 7, 0.5))   },   constraint = mle_constraint(support = function(theta) TRUE) )  # Strategies to compare strategies <- list(   \"Gradient Ascent\" = gradient_ascent(max_iter = 100),   \"BFGS\" = bfgs(),   \"Nelder-Mead\" = nelder_mead(),   \"SA + GA\" = sim_anneal(max_iter = 200) %>>% gradient_ascent(),   \"Restarts (5)\" = with_restarts(gradient_ascent(), n = 5,                                   sampler = function() runif(1, -5, 15)) )  # Run each strategy multiple times results <- data.frame(   Strategy = character(),   LogLike = numeric(),   Theta = numeric(),   stringsAsFactors = FALSE )  for (name in names(strategies)) {   for (rep in 1:3) {     set.seed(rep * 100)     theta0 <- runif(1, -5, 15)     result <- tryCatch(       strategies[[name]](bimodal, theta0),       error = function(e) NULL     )     if (!is.null(result)) {       results <- rbind(results, data.frame(         Strategy = name,         LogLike = result$loglike,         Theta = result$theta.hat[1],         stringsAsFactors = FALSE       ))     }   } } #> Warning in optim(par = theta0, fn = fn, method = \"Nelder-Mead\", control = list(maxit = max_iter, : one-dimensional optimization by Nelder-Mead is unreliable: #> use \"Brent\" or optimize() directly #> Warning in optim(par = theta0, fn = fn, method = \"Nelder-Mead\", control = list(maxit = max_iter, : one-dimensional optimization by Nelder-Mead is unreliable: #> use \"Brent\" or optimize() directly #> Warning in optim(par = theta0, fn = fn, method = \"Nelder-Mead\", control = list(maxit = max_iter, : one-dimensional optimization by Nelder-Mead is unreliable: #> use \"Brent\" or optimize() directly  # Summarize results library(dplyr) #>  #> Attaching package: 'dplyr' #> The following objects are masked from 'package:stats': #>  #>     filter, lag #> The following objects are masked from 'package:base': #>  #>     intersect, setdiff, setequal, union results %>%   group_by(Strategy) %>%   summarize(     MeanLogLike = round(mean(LogLike), 2),     BestTheta = round(Theta[which.max(LogLike)], 2),     .groups = \"drop\"   ) %>%   arrange(desc(MeanLogLike)) #> # A tibble: 5 × 3 #>   Strategy        MeanLogLike BestTheta #>   <chr>                 <dbl>     <dbl> #> 1 Restarts (5)          -0.58         7 #> 2 BFGS                  -0.86         7 #> 3 Gradient Ascent       -0.86         7 #> 4 Nelder-Mead           -0.86         7 #> 5 SA + GA               -0.86         7"},{"path":[]},{"path":"https://queelius.github.io/compositional.mle/articles/strategy-design.html","id":"start-simple-add-complexity","dir":"Articles","previous_headings":"Best Practices","what":"1. Start Simple, Add Complexity","title":"Designing Optimization Strategies","text":"","code":"# First try: simple gradient ascent result <- gradient_ascent()(problem, theta0)  # If it fails, add restarts result <- with_restarts(gradient_ascent(), n = 10, sampler = my_sampler)(problem, theta0)  # If still failing, try global + local result <- (sim_anneal() %>>% gradient_ascent())(problem, theta0)"},{"path":"https://queelius.github.io/compositional.mle/articles/strategy-design.html","id":"use-domain-knowledge-for-initialization","dir":"Articles","previous_headings":"Best Practices","what":"2. Use Domain Knowledge for Initialization","title":"Designing Optimization Strategies","text":"","code":"# Method of moments for mixture initialization m <- mean(data); v <- var(data) theta0 <- c(m - sqrt(v), sqrt(v), m + sqrt(v), sqrt(v), 0.5)"},{"path":[]},{"path":"https://queelius.github.io/compositional.mle/articles/strategy-design.html","id":"monitor-convergence","dir":"Articles","previous_headings":"Best Practices","what":"4. Monitor Convergence","title":"Designing Optimization Strategies","text":"Always enable tracing development:","code":"result <- solver(problem, theta0, trace = mle_trace(values = TRUE, gradients = TRUE)) plot(result)"},{"path":"https://queelius.github.io/compositional.mle/articles/strategy-design.html","id":"summary","dir":"Articles","previous_headings":"","what":"Summary","title":"Designing Optimization Strategies","text":"compositional approach lets : Combine strengths: Global search + local refinement Handle uncertainty: Race multiple methods Build robustness: Multiple restarts Diagnose issues: Full tracing visualization Start simple strategies add complexity needed.","code":""},{"path":"https://queelius.github.io/compositional.mle/articles/theory-and-intuition.html","id":"what-is-maximum-likelihood-estimation","dir":"Articles","previous_headings":"","what":"What is Maximum Likelihood Estimation?","title":"Theory and Intuition Behind Numerical MLE","text":"Maximum Likelihood Estimation (MLE) fundamental method estimating parameters statistical model. idea simple yet powerful: find parameter values make observed data probable.","code":""},{"path":"https://queelius.github.io/compositional.mle/articles/theory-and-intuition.html","id":"the-likelihood-function","dir":"Articles","previous_headings":"What is Maximum Likelihood Estimation?","what":"The Likelihood Function","title":"Theory and Intuition Behind Numerical MLE","text":"Suppose observe data x1,x2,…,xnx_1, x_2, \\ldots, x_n believe comes probability distribution parameter(s) θ\\theta. likelihood function L(θ)L(\\theta) measures probable observed data , given parameter θ\\theta: L(θ)=P(X1=x1,X2=x2,…,Xn=xn∣θ)L(\\theta) = P(X_1 = x_1, X_2 = x_2, \\ldots, X_n = x_n \\mid \\theta) independent observations: L(θ)=∏=1nf(xi∣θ)L(\\theta) = \\prod_{=1}^{n} f(x_i \\mid \\theta) f(⋅∣θ)f(\\cdot \\mid \\theta) probability density (mass) function.","code":""},{"path":"https://queelius.github.io/compositional.mle/articles/theory-and-intuition.html","id":"why-log-likelihood","dir":"Articles","previous_headings":"What is Maximum Likelihood Estimation?","what":"Why Log-Likelihood?","title":"Theory and Intuition Behind Numerical MLE","text":"Working products numerically unstable mathematically inconvenient. Taking logarithm converts products sums: ℓ(θ)=logL(θ)=∑=1nlogf(xi∣θ)\\ell(\\theta) = \\log L(\\theta) = \\sum_{=1}^{n} \\log f(x_i \\mid \\theta) Since log\\log monotonic, maximizing ℓ(θ)\\ell(\\theta) equivalent maximizing L(θ)L(\\theta). log-likelihood several advantages: Numerical stability: Products small probabilities can underflow zero Computational efficiency: Sums faster products Mathematical convenience: Derivatives sums easier derivatives products Statistical properties: curvature ℓ(θ)\\ell(\\theta) relates estimation uncertainty","code":""},{"path":"https://queelius.github.io/compositional.mle/articles/theory-and-intuition.html","id":"a-concrete-example","dir":"Articles","previous_headings":"What is Maximum Likelihood Estimation?","what":"A Concrete Example","title":"Theory and Intuition Behind Numerical MLE","text":"Let’s see normal data:  MLE point surface highest value (deepest red contour plot).","code":"set.seed(42) x <- rnorm(50, mean = 3, sd = 1.5)  # Log-likelihood function for normal distribution loglike <- function(theta) {   mu <- theta[1]   sigma <- theta[2]   if (sigma <= 0) return(-Inf)   sum(dnorm(x, mean = mu, sd = sigma, log = TRUE)) }  # Visualize the log-likelihood surface mu_grid <- seq(1, 5, length.out = 50) sigma_grid <- seq(0.5, 3, length.out = 50) ll_surface <- outer(mu_grid, sigma_grid, function(m, s) {   mapply(function(mi, si) loglike(c(mi, si)), m, s) })  # Contour plot contour(mu_grid, sigma_grid, ll_surface, nlevels = 20,         xlab = expression(mu), ylab = expression(sigma),         main = \"Log-Likelihood Surface\") points(mean(x), sd(x), pch = 19, col = \"red\", cex = 1.5) legend(\"topright\", \"MLE\", pch = 19, col = \"red\")"},{"path":"https://queelius.github.io/compositional.mle/articles/theory-and-intuition.html","id":"the-score-function","dir":"Articles","previous_headings":"","what":"The Score Function","title":"Theory and Intuition Behind Numerical MLE","text":"score function gradient (vector partial derivatives) log-likelihood: s(θ)=∇θℓ(θ)=(∂ℓ∂θ1,…,∂ℓ∂θp)s(\\theta) = \\nabla_\\theta \\ell(\\theta) = \\left( \\frac{\\partial \\ell}{\\partial \\theta_1}, \\ldots, \\frac{\\partial \\ell}{\\partial \\theta_p} \\right) MLE θ̂\\hat{\\theta}, score zero: s(θ̂)=0s(\\hat{\\theta}) = 0.","code":""},{"path":"https://queelius.github.io/compositional.mle/articles/theory-and-intuition.html","id":"intuition","dir":"Articles","previous_headings":"The Score Function","what":"Intuition","title":"Theory and Intuition Behind Numerical MLE","text":"score tells us direction steepest ascent log-likelihood surface. s(θ)≠0s(\\theta) \\neq 0, can increase likelihood moving direction s(θ)s(\\theta).","code":"# Score function for normal distribution score <- function(theta) {   mu <- theta[1]   sigma <- theta[2]   n <- length(x)   c(     sum(x - mu) / sigma^2,                        # d/d_mu     -n / sigma + sum((x - mu)^2) / sigma^3        # d/d_sigma   ) }  # At a point away from the MLE, the score points toward the MLE theta_start <- c(1, 0.8) s <- score(theta_start) cat(\"Score at (1, 0.8):\", round(s, 2), \"\\n\") #> Score at (1, 0.8): 152.07 593.01 cat(\"Direction: move\", ifelse(s[1] > 0, \"right\", \"left\"), \"in mu,\",     ifelse(s[2] > 0, \"up\", \"down\"), \"in sigma\\n\") #> Direction: move right in mu, up in sigma"},{"path":"https://queelius.github.io/compositional.mle/articles/theory-and-intuition.html","id":"gradient-ascent","dir":"Articles","previous_headings":"","what":"Gradient Ascent","title":"Theory and Intuition Behind Numerical MLE","text":"Gradient ascent simplest optimization algorithm. iteratively moves direction gradient: θ(t+1)=θ(t)+η⋅s(θ(t))\\theta^{(t+1)} = \\theta^{(t)} + \\eta \\cdot s(\\theta^{(t)}) η>0\\eta > 0 learning rate (step size).","code":""},{"path":"https://queelius.github.io/compositional.mle/articles/theory-and-intuition.html","id":"why-it-works","dir":"Articles","previous_headings":"Gradient Ascent","what":"Why It Works","title":"Theory and Intuition Behind Numerical MLE","text":"score points direction steepest increase. Taking small steps direction guarantees improvement (small enough η\\eta).","code":""},{"path":"https://queelius.github.io/compositional.mle/articles/theory-and-intuition.html","id":"the-challenge-choosing-the-step-size","dir":"Articles","previous_headings":"Gradient Ascent","what":"The Challenge: Choosing the Step Size","title":"Theory and Intuition Behind Numerical MLE","text":"large: might overshoot oscillate small: Convergence painfully slow","code":"# Demonstrate gradient ascent with different step sizes run_gradient_ascent <- function(eta, max_iter = 50) {   theta <- c(1, 0.8)   path <- matrix(NA, max_iter + 1, 2)   path[1, ] <- theta    for (i in 1:max_iter) {     theta <- theta + eta * score(theta)     if (theta[2] <= 0) theta[2] <- 0.01  # Enforce constraint     path[i + 1, ] <- theta   }   path }  # Compare step sizes path_small <- run_gradient_ascent(0.001) path_good <- run_gradient_ascent(0.01) path_large <- run_gradient_ascent(0.05)  # Plot paths contour(mu_grid, sigma_grid, ll_surface, nlevels = 15,         xlab = expression(mu), ylab = expression(sigma),         main = \"Gradient Ascent: Effect of Step Size\") lines(path_small[, 1], path_small[, 2], col = \"blue\", lwd = 2) lines(path_good[, 1], path_good[, 2], col = \"green\", lwd = 2) lines(path_large[1:20, 1], path_large[1:20, 2], col = \"red\", lwd = 2) points(mean(x), sd(x), pch = 19, cex = 1.5) legend(\"topright\", c(\"Small (0.001)\", \"Good (0.01)\", \"Large (0.05)\"),        col = c(\"blue\", \"green\", \"red\"), lwd = 2)"},{"path":"https://queelius.github.io/compositional.mle/articles/theory-and-intuition.html","id":"line-search-automatic-step-size-selection","dir":"Articles","previous_headings":"Gradient Ascent","what":"Line Search: Automatic Step Size Selection","title":"Theory and Intuition Behind Numerical MLE","text":"Backtracking line search adaptively finds good step size: Start large step size doesn’t improve objective enough, shrink Repeat find acceptable step","code":"# Define the problem problem <- mle_problem(   loglike = loglike,   score = score,   constraint = mle_constraint(     support = function(theta) theta[2] > 0,     project = function(theta) c(theta[1], max(theta[2], 1e-6))   ) )  result <- gradient_ascent(max_iter = 50)(problem, theta0 = c(1, 0.8))  cat(\"Final estimate:\", round(result$theta.hat, 4), \"\\n\") #> Final estimate: 2.9465 1.7099 cat(\"Iterations:\", result$iterations, \"\\n\") #> Iterations: 19 cat(\"Converged:\", result$converged, \"\\n\") #> Converged: FALSE"},{"path":"https://queelius.github.io/compositional.mle/articles/theory-and-intuition.html","id":"the-fisher-information-matrix","dir":"Articles","previous_headings":"","what":"The Fisher Information Matrix","title":"Theory and Intuition Behind Numerical MLE","text":"Fisher information matrix (θ)(\\theta) measures much information data carries θ\\theta. can defined equivalently : (θ)=−E[∂2ℓ∂θ∂θT]=E[s(θ)s(θ)T](\\theta) = -E\\left[ \\frac{\\partial^2 \\ell}{\\partial \\theta \\partial \\theta^T} \\right] = E\\left[ s(\\theta) s(\\theta)^T \\right] second form shows (θ)(\\theta) equals covariance score (since E[s(θ)]=0E[s(\\theta)] = 0 true parameter).","code":""},{"path":"https://queelius.github.io/compositional.mle/articles/theory-and-intuition.html","id":"why-it-matters","dir":"Articles","previous_headings":"The Fisher Information Matrix","what":"Why It Matters","title":"Theory and Intuition Behind Numerical MLE","text":"Curvature: (θ)(\\theta) describes curvature log-likelihood surface Uncertainty: asymptotic variance MLE Var(θ̂)≈(θ)−1\\text{Var}(\\hat{\\theta}) \\approx (\\theta)^{-1} (Cramér-Rao bound) Natural scaling: Different parameters may different scales; (θ)(\\theta) accounts ","code":""},{"path":"https://queelius.github.io/compositional.mle/articles/theory-and-intuition.html","id":"observed-vs-expected-fisher-information","dir":"Articles","previous_headings":"The Fisher Information Matrix","what":"Observed vs Expected Fisher Information","title":"Theory and Intuition Behind Numerical MLE","text":"Expected information: (θ)=−E[∇2ℓ(θ)](\\theta) = -E[\\nabla^2 \\ell(\\theta)] Observed information: J(θ)=−∇2ℓ(θ)J(\\theta) = -\\nabla^2 \\ell(\\theta) (evaluated data) practice, often use observed information, doesn’t require computing expectations.","code":""},{"path":"https://queelius.github.io/compositional.mle/articles/theory-and-intuition.html","id":"newton-raphson","dir":"Articles","previous_headings":"","what":"Newton-Raphson","title":"Theory and Intuition Behind Numerical MLE","text":"Newton-Raphson uses Fisher information take smarter steps: θ(t+1)=θ(t)+(θ(t))−1s(θ(t))\\theta^{(t+1)} = \\theta^{(t)} + (\\theta^{(t)})^{-1} s(\\theta^{(t)})","code":""},{"path":"https://queelius.github.io/compositional.mle/articles/theory-and-intuition.html","id":"intuition-1","dir":"Articles","previous_headings":"Newton-Raphson","what":"Intuition","title":"Theory and Intuition Behind Numerical MLE","text":"Gradient ascent treats directions equally, directions might “easier” move others. Newton-Raphson pre-multiplies −1I^{-1}, : Takes larger steps flat directions (low curvature) Takes smaller steps curved directions (high curvature) Accounts correlations parameters","code":""},{"path":"https://queelius.github.io/compositional.mle/articles/theory-and-intuition.html","id":"comparison","dir":"Articles","previous_headings":"Newton-Raphson","what":"Comparison","title":"Theory and Intuition Behind Numerical MLE","text":"Newton-Raphson typically converges much faster, especially near optimum quadratic convergence kicks .","code":"# Fisher information for normal distribution fisher <- function(theta) {   sigma <- theta[2]   n <- length(x)   matrix(c(     n / sigma^2, 0,     0, 2 * n / sigma^2   ), nrow = 2) }  # Define problem with Fisher information problem_with_fisher <- mle_problem(   loglike = loglike,   score = score,   fisher = fisher,   constraint = mle_constraint(     support = function(theta) theta[2] > 0,     project = function(theta) c(theta[1], max(theta[2], 1e-6))   ) )  # Run gradient ascent result_ga <- gradient_ascent(max_iter = 100)(problem, theta0 = c(1, 0.8))  # Run Newton-Raphson result_nr <- newton_raphson(max_iter = 100)(problem_with_fisher, theta0 = c(1, 0.8))  cat(\"Gradient Ascent: \", result_ga$iterations, \"iterations\\n\") #> Gradient Ascent:  19 iterations cat(\"Newton-Raphson:  \", result_nr$iterations, \"iterations\\n\") #> Newton-Raphson:   20 iterations"},{"path":"https://queelius.github.io/compositional.mle/articles/theory-and-intuition.html","id":"composing-solvers","dir":"Articles","previous_headings":"","what":"Composing Solvers","title":"Theory and Intuition Behind Numerical MLE","text":"compositional.mle package lets compose optimization strategies:","code":"# Coarse-to-fine: grid search finds a good region, Newton polishes strategy <- grid_search(lower = c(0, 0.1), upper = c(6, 4), n = 5) %>>%   newton_raphson(max_iter = 20)  result <- strategy(problem_with_fisher, theta0 = c(1, 0.8)) cat(\"Result:\", round(result$theta.hat, 4), \"\\n\") #> Result: 2.9465 1.7099  # Race different methods, pick the best strategy <- gradient_ascent() %|% bfgs() %|% nelder_mead() result <- strategy(problem, theta0 = c(1, 0.8)) cat(\"Winner:\", result$solver, \"\\n\") #> Winner: gradient_ascent"},{"path":[]},{"path":"https://queelius.github.io/compositional.mle/articles/theory-and-intuition.html","id":"constrained-optimization","dir":"Articles","previous_headings":"","what":"Constrained Optimization","title":"Theory and Intuition Behind Numerical MLE","text":"Real problems often constraints parameters: Variance must positive: σ>0\\sigma > 0 Probabilities must [0,1][0, 1] Correlation must satisfy |ρ|<1|\\rho| < 1","code":""},{"path":"https://queelius.github.io/compositional.mle/articles/theory-and-intuition.html","id":"projection-method","dir":"Articles","previous_headings":"Constrained Optimization","what":"Projection Method","title":"Theory and Intuition Behind Numerical MLE","text":"compositional.mle package uses projection: step takes us outside feasible region, project back nearest feasible point.","code":"# The constraint keeps sigma positive throughout optimization result <- gradient_ascent(max_iter = 100)(problem, theta0 = c(0, 0.1))  cat(\"Final sigma:\", result$theta.hat[2], \"> 0 (constraint satisfied)\\n\") #> Final sigma: 1.709855 > 0 (constraint satisfied)"},{"path":"https://queelius.github.io/compositional.mle/articles/theory-and-intuition.html","id":"regularization-and-penalized-likelihood","dir":"Articles","previous_headings":"","what":"Regularization and Penalized Likelihood","title":"Theory and Intuition Behind Numerical MLE","text":"Sometimes want penalize certain parameter values : Prevent overfitting Encourage sparsity Incorporate prior beliefs","code":""},{"path":"https://queelius.github.io/compositional.mle/articles/theory-and-intuition.html","id":"penalized-log-likelihood","dir":"Articles","previous_headings":"Regularization and Penalized Likelihood","what":"Penalized Log-Likelihood","title":"Theory and Intuition Behind Numerical MLE","text":"ℓλ(θ)=ℓ(θ)−λ⋅P(θ)\\ell_\\lambda(\\theta) = \\ell(\\theta) - \\lambda \\cdot P(\\theta) P(θ)P(\\theta) penalty function λ>0\\lambda > 0 controls regularization strength.","code":""},{"path":"https://queelius.github.io/compositional.mle/articles/theory-and-intuition.html","id":"common-penalties","dir":"Articles","previous_headings":"Regularization and Penalized Likelihood","what":"Common Penalties","title":"Theory and Intuition Behind Numerical MLE","text":"L1 (LASSO): P(θ)=∑j|θj|P(\\theta) = \\sum_j |\\theta_j| Encourages sparsity (θj=0\\theta_j = 0) Useful variable selection L2 (Ridge): P(θ)=∑jθj2P(\\theta) = \\sum_j \\theta_j^2 Shrinks parameters toward zero Prevents extreme values Equivalent Gaussian prior Elastic Net: P(θ)=α∑j|θj|+(1−α)∑jθj2P(\\theta) = \\alpha \\sum_j |\\theta_j| + (1-\\alpha) \\sum_j \\theta_j^2 Combines L1 L2 benefits α\\alpha controls mix","code":"# Original log-likelihood (maximum at theta = (3,2)) loglike_simple <- function(theta) -sum((theta - c(3, 2))^2)  # Add L2 penalty loglike_l2 <- with_penalty(loglike_simple, penalty_l2(), lambda = 1)  # Compare theta <- c(3, 2) cat(\"At theta = (3, 2):\\n\") #> At theta = (3, 2): cat(\"  Original:\", loglike_simple(theta), \"\\n\") #>   Original: 0 cat(\"  With L2 penalty:\", loglike_l2(theta), \"\\n\") #>   With L2 penalty: -13 cat(\"  The penalty shrinks the solution toward zero\\n\") #>   The penalty shrinks the solution toward zero"},{"path":"https://queelius.github.io/compositional.mle/articles/theory-and-intuition.html","id":"summary","dir":"Articles","previous_headings":"","what":"Summary","title":"Theory and Intuition Behind Numerical MLE","text":"compositional.mle package provides composable solvers can chained (%>>%), raced (%|%), restarted (with_restarts()) handle real-world complexities like constraints, regularization, multimodal surfaces.","code":""},{"path":"https://queelius.github.io/compositional.mle/articles/theory-and-intuition.html","id":"further-reading","dir":"Articles","previous_headings":"","what":"Further Reading","title":"Theory and Intuition Behind Numerical MLE","text":"Casella, G. Berger, R.L. (2002). Statistical Inference. Duxbury. Nocedal, J. Wright, S.J. (2006). Numerical Optimization. Springer. Murphy, K.P. (2012). Machine Learning: Probabilistic Perspective. MIT Press.","code":""},{"path":"https://queelius.github.io/compositional.mle/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Alexander Towell. Author, maintainer.","code":""},{"path":"https://queelius.github.io/compositional.mle/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Towell (2026). compositional.mle: Compositional Maximum Likelihood Estimation. R package version 1.0.0, https://github.com/queelius/compositional.mle.","code":"@Manual{,   title = {compositional.mle: Compositional Maximum Likelihood Estimation},   author = {Alexander Towell},   year = {2026},   note = {R package version 1.0.0},   url = {https://github.com/queelius/compositional.mle}, }"},{"path":[]},{"path":"https://queelius.github.io/compositional.mle/index.html","id":"when-to-use-this-package","dir":"","previous_headings":"","what":"When to Use This Package","title":"Compositional Maximum Likelihood Estimation","text":"Use compositional.mle : Multi-modal likelihoods: likelihood surface multiple local optima need global search strategies (simulated annealing, random restarts) Coarse--fine optimization: want start rough global search progressively refine local methods Comparing strategies: ’re unsure optimizer works best want race automatically Building robust pipelines: need reliable estimation handles edge cases gracefully Research/experimentation: want explore optimization strategies visualize convergence Stick optim() : simple, well-behaved likelihood single optimum know exactly method works don’t need composition","code":""},{"path":"https://queelius.github.io/compositional.mle/index.html","id":"example-why-composition-matters","dir":"","previous_headings":"When to Use This Package","what":"Example: Why Composition Matters","title":"Compositional Maximum Likelihood Estimation","text":"","code":"library(compositional.mle)  # A tricky bimodal likelihood set.seed(42) bimodal_loglike <- function(theta) {   # Two peaks: one at theta=2, one at theta=8   log(0.3 * dnorm(theta, 2, 0.5) + 0.7 * dnorm(theta, 8, 0.5)) }  problem <- mle_problem(  loglike = bimodal_loglike,   constraint = mle_constraint(support = function(theta) TRUE) )  # Single gradient ascent gets trapped at local optimum result_local <- gradient_ascent()(problem, theta0 = 0)  # Simulated annealing + gradient ascent finds global optimum strategy <- sim_anneal(temp_init = 5, max_iter = 200) %>>% gradient_ascent() result_global <- strategy(problem, theta0 = 0)  cat(\"Local search found:\", round(result_local$theta.hat, 2),     \"(log-lik:\", round(result_local$loglike, 2), \")\\n\") #> Local search found: 2 (log-lik: -1.43 ) cat(\"Global strategy found:\", round(result_global$theta.hat, 2),     \"(log-lik:\", round(result_global$loglike, 2), \")\\n\") #> Global strategy found: 2 (log-lik: -1.43 )"},{"path":"https://queelius.github.io/compositional.mle/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Compositional Maximum Likelihood Estimation","text":"","code":"# From CRAN (when available) install.packages(\"compositional.mle\")  # Development version devtools::install_github(\"queelius/compositional.mle\")"},{"path":"https://queelius.github.io/compositional.mle/index.html","id":"design-philosophy","dir":"","previous_headings":"","what":"Design Philosophy","title":"Compositional Maximum Likelihood Estimation","text":"Following SICP principles, package provides: 1. Primitive solvers - gradient_ascent(), newton_raphson(), bfgs(), sim_anneal(), etc. 2. Composition operators - %>>% (sequential), %|% (race), with_restarts() 3. Closure property - Combining solvers yields solver","code":""},{"path":"https://queelius.github.io/compositional.mle/index.html","id":"quick-start","dir":"","previous_headings":"","what":"Quick Start","title":"Compositional Maximum Likelihood Estimation","text":"","code":"# Generate sample data set.seed(42) x <- rnorm(100, mean = 5, sd = 2)  # Define the problem (separate from solver strategy) problem <- mle_problem(   loglike = function(theta) {     if (theta[2] <= 0) return(-Inf)     sum(dnorm(x, theta[1], theta[2], log = TRUE))   },   score = function(theta) {     mu <- theta[1]; sigma <- theta[2]; n <- length(x)     c(sum(x - mu) / sigma^2,       -n / sigma + sum((x - mu)^2) / sigma^3)   },   constraint = mle_constraint(     support = function(theta) theta[2] > 0,     project = function(theta) c(theta[1], max(theta[2], 1e-8))   ) )  # Simple solve result <- gradient_ascent()(problem, theta0 = c(0, 1)) result$theta.hat #> [1] 5.065030 2.072274"},{"path":[]},{"path":"https://queelius.github.io/compositional.mle/index.html","id":"sequential-chaining-","dir":"","previous_headings":"Composing Solvers","what":"Sequential Chaining (%>>%)","title":"Compositional Maximum Likelihood Estimation","text":"Chain solvers coarse--fine optimization:","code":"# Grid search -> gradient ascent -> Newton-Raphson strategy <- grid_search(lower = c(-10, 0.5), upper = c(10, 5), n = 5) %>>%   gradient_ascent(max_iter = 50) %>>%   newton_raphson(max_iter = 20)  result <- strategy(problem, theta0 = c(0, 1)) result$theta.hat #>     Var1     Var2  #> 5.065030 2.072274"},{"path":"https://queelius.github.io/compositional.mle/index.html","id":"parallel-racing-","dir":"","previous_headings":"Composing Solvers","what":"Parallel Racing (%|%)","title":"Compositional Maximum Likelihood Estimation","text":"Race multiple methods, keep best:","code":"# Try multiple approaches, pick winner by log-likelihood strategy <- gradient_ascent() %|% bfgs() %|% nelder_mead()  result <- strategy(problem, theta0 = c(0, 1)) c(result$theta.hat, loglike = result$loglike) #>                             loglike  #>    5.065030    2.072274 -214.758518"},{"path":"https://queelius.github.io/compositional.mle/index.html","id":"random-restarts","dir":"","previous_headings":"Composing Solvers","what":"Random Restarts","title":"Compositional Maximum Likelihood Estimation","text":"Escape local optima multiple starting points:","code":"strategy <- with_restarts(   gradient_ascent(),   n = 10,   sampler = uniform_sampler(c(-10, 0.5), c(10, 5)) )  result <- strategy(problem, theta0 = c(0, 1)) result$theta.hat #> [1] 5.065030 2.072274"},{"path":"https://queelius.github.io/compositional.mle/index.html","id":"visualization","dir":"","previous_headings":"","what":"Visualization","title":"Compositional Maximum Likelihood Estimation","text":"Track visualize optimization path:  Extract trace data frame custom analysis:","code":"# Enable tracing trace_cfg <- mle_trace(values = TRUE, gradients = TRUE, path = TRUE) result <- gradient_ascent(max_iter = 50)(problem, c(0, 1), trace = trace_cfg)  # Plot convergence plot(result, which = c(\"loglike\", \"gradient\")) path_df <- optimization_path(result) head(path_df) #>   iteration    loglike  grad_norm   theta_1  theta_2 #> 1         1 -1589.3361 2938.86063 0.0000000 1.000000 #> 2         2  -518.7066  334.47435 0.1723467 1.985036 #> 3         3  -344.5384   84.57555 0.5435804 2.913576 #> 4         4  -293.8366   30.83372 1.1733478 3.690360 #> 5         5  -271.7336   18.65296 2.1001220 4.065978 #> 6         6  -254.0618   17.83778 3.0615865 3.791049"},{"path":[]},{"path":"https://queelius.github.io/compositional.mle/index.html","id":"function-transformers","dir":"","previous_headings":"","what":"Function Transformers","title":"Compositional Maximum Likelihood Estimation","text":"","code":"# Stochastic gradient (mini-batching for large data) loglike_sgd <- with_subsampling(loglike, data = x, subsample_size = 32)  # Regularization loglike_l2 <- with_penalty(loglike, penalty_l2(), lambda = 0.1) loglike_l1 <- with_penalty(loglike, penalty_l1(), lambda = 0.1)"},{"path":"https://queelius.github.io/compositional.mle/index.html","id":"documentation","dir":"","previous_headings":"","what":"Documentation","title":"Compositional Maximum Likelihood Estimation","text":"Full documentation: https://queelius.github.io/compositional.mle/ Getting Started Case Studies Theory Intuition","code":""},{"path":"https://queelius.github.io/compositional.mle/index.html","id":"license","dir":"","previous_headings":"","what":"License","title":"Compositional Maximum Likelihood Estimation","text":"MIT","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/bfgs.html","id":null,"dir":"Reference","previous_headings":"","what":"BFGS Solver — bfgs","title":"BFGS Solver — bfgs","text":"Creates solver using BFGS quasi-Newton method via optim(). BFGS approximates Hessian gradient information, providing second-order-like convergence without computing Hessian directly.","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/bfgs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"BFGS Solver — bfgs","text":"","code":"bfgs(max_iter = 100L, tol = 1e-08, report = 0L)"},{"path":"https://queelius.github.io/compositional.mle/reference/bfgs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"BFGS Solver — bfgs","text":"max_iter Maximum number iterations tol Convergence tolerance (passed optim's reltol) report Reporting frequency (0 = reporting)","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/bfgs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"BFGS Solver — bfgs","text":"solver function signature (problem, theta0, trace) -> mle_result","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/bfgs.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"BFGS Solver — bfgs","text":"BFGS often good default choice: robust Newton-Raphson (matrix inversion issues) faster gradient ascent (uses curvature information). solver automatically uses score function problem available, otherwise computes gradients numerically.","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/bfgs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"BFGS Solver — bfgs","text":"","code":"# \\donttest{ set.seed(42) x <- rnorm(50, 5, 2) problem <- mle_problem(   loglike = function(theta) sum(dnorm(x, theta[1], theta[2], log = TRUE)),   constraint = mle_constraint(support = function(theta) theta[2] > 0,                               project = function(theta) c(theta[1], max(theta[2], 1e-8))) ) # Basic usage result <- bfgs()(problem, c(4, 1.5))  # Race BFGS against gradient ascent strategy <- bfgs() %|% gradient_ascent() # }"},{"path":"https://queelius.github.io/compositional.mle/reference/chain.html","id":null,"dir":"Reference","previous_headings":"","what":"Chain Solvers with Early Stopping — chain","title":"Chain Solvers with Early Stopping — chain","text":"Chains multiple solvers sequentially optional early stopping. flexible %>>% operator.","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/chain.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Chain Solvers with Early Stopping — chain","text":"","code":"chain(..., early_stop = NULL)"},{"path":"https://queelius.github.io/compositional.mle/reference/chain.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Chain Solvers with Early Stopping — chain","text":"... Solver functions chain early_stop Optional function takes result returns TRUE stop chain early. Default NULL (early stopping).","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/chain.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Chain Solvers with Early Stopping — chain","text":"new solver function runs solvers sequence","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/chain.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Chain Solvers with Early Stopping — chain","text":"chain runs solvers order, passing result's theta.hat next solver. early_stop provided returns TRUE intermediate result, chain stops early. Common early stopping conditions: Stop converged: function(r) r$converged Stop gradient small: function(r) sqrt(sum(score^2)) < 1e-6 Stop reaching target: function(r) r$loglike > -100","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/chain.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Chain Solvers with Early Stopping — chain","text":"","code":"# Chain with early stopping when converged strategy <- chain(   grid_search(lower = c(-10, 0.1), upper = c(10, 5), n = 5),   gradient_ascent(max_iter = 50),   newton_raphson(max_iter = 20),   early_stop = function(r) isTRUE(r$converged) ) #> Error in chain(grid_search(lower = c(-10, 0.1), upper = c(10, 5), n = 5),     gradient_ascent(max_iter = 50), newton_raphson(max_iter = 20),     early_stop = function(r) isTRUE(r$converged)): could not find function \"chain\"  # Standard chain (no early stopping) strategy <- chain(gradient_ascent(), newton_raphson()) #> Error in chain(gradient_ascent(), newton_raphson()): could not find function \"chain\""},{"path":"https://queelius.github.io/compositional.mle/reference/clear_cache.html","id":null,"dir":"Reference","previous_headings":"","what":"Clear derivative cache — clear_cache","title":"Clear derivative cache — clear_cache","text":"Clears cached numerical derivatives (score Fisher) mle_problem. useful want force recomputation, example modifying data log-likelihood depends .","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/clear_cache.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Clear derivative cache — clear_cache","text":"","code":"clear_cache(problem)"},{"path":"https://queelius.github.io/compositional.mle/reference/clear_cache.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Clear derivative cache — clear_cache","text":"problem mle_problem object","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/clear_cache.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Clear derivative cache — clear_cache","text":"problem object (invisibly), modified place","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/clear_cache.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Clear derivative cache — clear_cache","text":"","code":"# \\donttest{ loglike <- function(theta) -sum((theta - c(1, 2))^2) problem <- mle_problem(loglike, cache_derivatives = TRUE) #> Error in mle_problem(loglike, cache_derivatives = TRUE): unused argument (cache_derivatives = TRUE) # ... run some optimization ... clear_cache(problem)  # Force fresh derivative computation #> Error in clear_cache(problem): could not find function \"clear_cache\" # }"},{"path":"https://queelius.github.io/compositional.mle/reference/compose.html","id":null,"dir":"Reference","previous_headings":"","what":"Compose Multiple Solvers Sequentially — compose","title":"Compose Multiple Solvers Sequentially — compose","text":"Chains number solvers sequentially. solver's result becomes starting point next. Alternative using %>>% operator.","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/compose.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compose Multiple Solvers Sequentially — compose","text":"","code":"compose(...)"},{"path":"https://queelius.github.io/compositional.mle/reference/compose.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compose Multiple Solvers Sequentially — compose","text":"... Solver functions compose","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/compose.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compose Multiple Solvers Sequentially — compose","text":"new solver function runs solvers sequence","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/compose.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compose Multiple Solvers Sequentially — compose","text":"Trace data solvers merged single trace stage boundaries preserved.","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/compose.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compose Multiple Solvers Sequentially — compose","text":"","code":"# \\donttest{ set.seed(42) x <- rnorm(50, 5, 2) problem <- mle_problem(   loglike = function(theta) sum(dnorm(x, theta[1], theta[2], log = TRUE)),   constraint = mle_constraint(support = function(theta) theta[2] > 0,                               project = function(theta) c(theta[1], max(theta[2], 1e-8))) ) # Three-stage strategy strategy <- compose(   grid_search(lower = c(-10, 0.1), upper = c(10, 5), n = 5),   gradient_ascent(max_iter = 50),   newton_raphson(max_iter = 20) ) result <- strategy(problem, c(0, 1)) #> Error in strategy(problem, c(0, 1)): unused argument (c(0, 1)) # }"},{"path":"https://queelius.github.io/compositional.mle/reference/compose_transforms.html","id":null,"dir":"Reference","previous_headings":"","what":"Compose Multiple Function Transformations — compose_transforms","title":"Compose Multiple Function Transformations — compose_transforms","text":"Applies transformations right--left (like mathematical composition). allows building complex log-likelihood transformations simple ones.","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/compose_transforms.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compose Multiple Function Transformations — compose_transforms","text":"","code":"compose_transforms(...)"},{"path":"https://queelius.github.io/compositional.mle/reference/compose_transforms.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compose Multiple Function Transformations — compose_transforms","text":"... Transformer functions","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/compose_transforms.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compose Multiple Function Transformations — compose_transforms","text":"Composed transformer function","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/compose_transforms.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compose Multiple Function Transformations — compose_transforms","text":"Note: composing solvers, use compose instead.","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/compose_transforms.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compose Multiple Function Transformations — compose_transforms","text":"","code":"# \\donttest{ # Create a composition of transformations transform <- compose_transforms(   function(f) with_penalty(f, penalty_l1(), lambda = 0.01),   function(f) with_penalty(f, penalty_l2(), lambda = 0.05) ) #> Error in compose_transforms(function(f) with_penalty(f, penalty_l1(),     lambda = 0.01), function(f) with_penalty(f, penalty_l2(),     lambda = 0.05)): could not find function \"compose_transforms\"  # Apply to log-likelihood loglike <- function(theta) -sum((theta - c(1, 2))^2) loglike_transformed <- transform(loglike) #> Error in as.data.frame.default(x[[i]], optional = TRUE): cannot coerce class ‘\"function\"’ to a data.frame loglike_transformed(c(1, 2)) #> Error in loglike_transformed(c(1, 2)): could not find function \"loglike_transformed\" # }"},{"path":"https://queelius.github.io/compositional.mle/reference/compositional.mle-package.html","id":null,"dir":"Reference","previous_headings":"","what":"compositional.mle: Compositional Maximum Likelihood Estimation — compositional.mle-package","title":"compositional.mle: Compositional Maximum Likelihood Estimation — compositional.mle-package","text":"Provides composable optimization strategies maximum likelihood estimation (MLE). Solvers first-class functions combine via sequential chaining, parallel racing, random restarts. Implements gradient ascent, Newton-Raphson, quasi-Newton (BFGS), derivative-free methods support constrained optimization tracing. Returns 'mle' objects compatible 'algebraic.mle' downstream analysis. Methods based Nocedal J, Wright SJ (2006) \"Numerical Optimization\" doi:10.1007/978-0-387-40065-5 . domain-specific language maximum likelihood estimation solvers first-class composable functions. Following SICP principles, solvers combine via sequential chaining, parallel racing, iteration build sophisticated optimization strategies simple primitives.","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/compositional.mle-package.html","id":"the-problem-abstraction","dir":"Reference","previous_headings":"","what":"The Problem Abstraction","title":"compositional.mle: Compositional Maximum Likelihood Estimation — compositional.mle-package","text":"mle_problem encapsulates statistical estimation problem: Log-likelihood function Optional analytic score Fisher information (computed numerically provided) Domain constraints Metadata (parameter names, observation count)","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/compositional.mle-package.html","id":"solver-factories","dir":"Reference","previous_headings":"","what":"Solver Factories","title":"compositional.mle: Compositional Maximum Likelihood Estimation — compositional.mle-package","text":"Solver factories return solver functions signature (problem, theta0, trace) -> mle_result: gradient_ascent: First-order gradient method newton_raphson: Second-order Newton's method bfgs: Quasi-Newton BFGS nelder_mead: Derivative-free simplex grid_search: Exhaustive grid search","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/compositional.mle-package.html","id":"composition-operators","dir":"Reference","previous_headings":"","what":"Composition Operators","title":"compositional.mle: Compositional Maximum Likelihood Estimation — compositional.mle-package","text":"Combine solvers build complex strategies: %>>%: Sequential chaining (coarse--fine) %|%: Parallel racing (try multiple, pick best) with_restarts: Multiple random starting points","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/compositional.mle-package.html","id":"tracing","dir":"Reference","previous_headings":"","what":"Tracing","title":"compositional.mle: Compositional Maximum Likelihood Estimation — compositional.mle-package","text":"mle_trace configures track optimization (values, path, gradients, timing) diagnostics visualization.","code":""},{"path":[]},{"path":"https://queelius.github.io/compositional.mle/reference/compositional.mle-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"compositional.mle: Compositional Maximum Likelihood Estimation — compositional.mle-package","text":"Maintainer: Alexander Towell queelius@gmail.com (ORCID)","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/compositional.mle-package.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"compositional.mle: Compositional Maximum Likelihood Estimation — compositional.mle-package","text":"","code":"# \\donttest{ # Define problem set.seed(42) x <- rnorm(100, mean = 5, sd = 2) problem <- mle_problem(   loglike = function(theta) sum(dnorm(x, theta[1], theta[2], log = TRUE)),   constraint = mle_constraint(support = function(theta) theta[2] > 0,                               project = function(theta) c(theta[1], max(theta[2], 1e-8))) )  # Simple solve result <- gradient_ascent()(problem, c(0, 1))  # Composed strategy: grid -> gradient -> Newton strategy <- grid_search(lower = c(-10, 0.1), upper = c(10, 5), n = 5) %>>%   gradient_ascent() %>>% newton_raphson() result <- strategy(problem, c(0, 1))  # Race different methods strategy <- gradient_ascent() %|% bfgs() %|% nelder_mead() result <- strategy(problem, c(0, 1)) # }"},{"path":"https://queelius.github.io/compositional.mle/reference/coordinate_ascent.html","id":null,"dir":"Reference","previous_headings":"","what":"Coordinate Ascent Solver — coordinate_ascent","title":"Coordinate Ascent Solver — coordinate_ascent","text":"Creates solver optimizes one parameter time holding others fixed. useful parameters different scales likelihood decomposes nicely along coordinate directions.","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/coordinate_ascent.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Coordinate Ascent Solver — coordinate_ascent","text":"","code":"coordinate_ascent(   max_cycles = 50L,   tol = 1e-08,   line_search = TRUE,   cycle_order = c(\"sequential\", \"random\"),   verbose = FALSE )"},{"path":"https://queelius.github.io/compositional.mle/reference/coordinate_ascent.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Coordinate Ascent Solver — coordinate_ascent","text":"max_cycles Maximum number full cycles parameters tol Convergence tolerance log-likelihood change line_search Use line search coordinate (slower robust) cycle_order Order cycling: \"sequential\" (1,2,...,p) \"random\" verbose Logical; TRUE cli package installed, display progress optimization. Default FALSE.","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/coordinate_ascent.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Coordinate Ascent Solver — coordinate_ascent","text":"solver function signature (problem, theta0, trace) -> mle_result","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/coordinate_ascent.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Coordinate Ascent Solver — coordinate_ascent","text":"cycle consists optimizing coordinate turn using simple golden section search. algorithm converges log-likelihood improvement full cycle less tol. Coordinate ascent can effective : Parameters different scales likelihood axis-aligned ridges Computing full gradient expensive However, may converge slowly problems strong parameter correlations.","code":""},{"path":[]},{"path":"https://queelius.github.io/compositional.mle/reference/coordinate_ascent.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Coordinate Ascent Solver — coordinate_ascent","text":"","code":"# Basic coordinate ascent solver <- coordinate_ascent()  # With more cycles for difficult problems solver <- coordinate_ascent(max_cycles = 100)  # Random cycling to avoid systematic bias solver <- coordinate_ascent(cycle_order = \"random\")"},{"path":"https://queelius.github.io/compositional.mle/reference/dot-backtracking_line_search.html","id":null,"dir":"Reference","previous_headings":"","what":"Backtracking line search — .backtracking_line_search","title":"Backtracking line search — .backtracking_line_search","text":"Backtracking line search","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/dot-backtracking_line_search.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Backtracking line search — .backtracking_line_search","text":"","code":".backtracking_line_search(   loglike,   theta,   direction,   max_step,   backtrack_ratio,   min_step,   constraint )"},{"path":"https://queelius.github.io/compositional.mle/reference/dot-coordinate_line_search.html","id":null,"dir":"Reference","previous_headings":"","what":"Golden section line search along one coordinate — .coordinate_line_search","title":"Golden section line search along one coordinate — .coordinate_line_search","text":"Golden section line search along one coordinate","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/dot-coordinate_line_search.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Golden section line search along one coordinate — .coordinate_line_search","text":"","code":".coordinate_line_search(   loglike,   theta,   coord,   constraint,   max_iter = 50,   tol = 1e-08 )"},{"path":"https://queelius.github.io/compositional.mle/reference/dot-coordinate_line_search.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Golden section line search along one coordinate — .coordinate_line_search","text":"loglike Log-likelihood function theta Current parameter vector coord Index coordinate optimize constraint Constraint object","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/dot-has_cli.html","id":null,"dir":"Reference","previous_headings":"","what":"Check if cli package is available — .has_cli","title":"Check if cli package is available — .has_cli","text":"Check cli package available","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/dot-has_cli.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check if cli package is available — .has_cli","text":"","code":".has_cli()"},{"path":"https://queelius.github.io/compositional.mle/reference/dot-progress_handler.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a progress handler for optimization — .progress_handler","title":"Create a progress handler for optimization — .progress_handler","text":"Create progress handler optimization","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/dot-progress_handler.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a progress handler for optimization — .progress_handler","text":"","code":".progress_handler(   verbose = FALSE,   solver_name = \"Solver\",   max_iter = NULL,   show_every = 1L )"},{"path":"https://queelius.github.io/compositional.mle/reference/dot-progress_handler.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a progress handler for optimization — .progress_handler","text":"verbose Logical; whether show progress solver_name Name solver display max_iter Maximum iterations (progress bar) show_every Show progress every N iterations","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/dot-progress_handler.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a progress handler for optimization — .progress_handler","text":"list start(), update(), finish() functions","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/finalize_trace.html","id":null,"dir":"Reference","previous_headings":"","what":"Finalize trace recorder into trace data — finalize_trace","title":"Finalize trace recorder into trace data — finalize_trace","text":"Finalize trace recorder trace data","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/finalize_trace.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Finalize trace recorder into trace data — finalize_trace","text":"","code":"finalize_trace(recorder)"},{"path":"https://queelius.github.io/compositional.mle/reference/finalize_trace.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Finalize trace recorder into trace data — finalize_trace","text":"recorder Trace recorder","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/finalize_trace.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Finalize trace recorder into trace data — finalize_trace","text":"List trace data NULL","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/fisher_scoring.html","id":null,"dir":"Reference","previous_headings":"","what":"Fisher Scoring Solver — fisher_scoring","title":"Fisher Scoring Solver — fisher_scoring","text":"Variant Newton-Raphson uses expected Fisher information instead observed Fisher. Can stable problems.","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/fisher_scoring.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fisher Scoring Solver — fisher_scoring","text":"","code":"fisher_scoring(   line_search = TRUE,   max_iter = 50L,   tol = 1e-08,   backtrack_ratio = 0.5,   min_step = 1e-12,   verbose = FALSE )"},{"path":"https://queelius.github.io/compositional.mle/reference/fisher_scoring.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fisher Scoring Solver — fisher_scoring","text":"line_search Use backtracking line search stability max_iter Maximum number iterations tol Convergence tolerance (parameter change) backtrack_ratio Step size reduction factor line search min_step Minimum step size giving verbose Logical; TRUE cli package installed, display progress optimization. Default FALSE.","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/fisher_scoring.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fisher Scoring Solver — fisher_scoring","text":"solver function signature (problem, theta0, trace) ->   mle_result","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/fisher_scoring.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Fisher Scoring Solver — fisher_scoring","text":"Fisher scoring identical Newton-Raphson expected observed Fisher information equal (e.g., exponential families). models, may different convergence properties.","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/fisher_scoring.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fisher Scoring Solver — fisher_scoring","text":"","code":"# \\donttest{ set.seed(42) x <- rnorm(50, 5, 2) problem <- mle_problem(   loglike = function(theta) sum(dnorm(x, theta[1], theta[2], log = TRUE)),   constraint = mle_constraint(     support = function(theta) theta[2] > 0,     project = function(theta) c(theta[1], max(theta[2], 1e-8))   ) ) solver <- fisher_scoring() result <- solver(problem, c(4, 1.5)) # }"},{"path":"https://queelius.github.io/compositional.mle/reference/get_fisher.html","id":null,"dir":"Reference","previous_headings":"","what":"Get Fisher information function from problem — get_fisher","title":"Get Fisher information function from problem — get_fisher","text":"Returns Fisher information matrix function, computing numerically provided. cache_derivatives = TRUE set problem Fisher computed numerically, results cached using single-value cache.","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/get_fisher.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get Fisher information function from problem — get_fisher","text":"","code":"get_fisher(problem)"},{"path":"https://queelius.github.io/compositional.mle/reference/get_fisher.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get Fisher information function from problem — get_fisher","text":"problem mle_problem object","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/get_fisher.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get Fisher information function from problem — get_fisher","text":"Fisher information function takes parameter vector   returns Fisher information matrix (negative Hessian log-likelihood).","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/get_fisher.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get Fisher information function from problem — get_fisher","text":"","code":"problem <- mle_problem(   loglike = function(theta) -sum((theta - c(1, 2))^2) ) fisher_fn <- get_fisher(problem) fisher_fn(c(1, 2))  # Fisher information at the optimum #>              [,1]         [,2] #> [1,]  2.00000e+00 -1.52056e-17 #> [2,] -1.52056e-17  2.00000e+00"},{"path":"https://queelius.github.io/compositional.mle/reference/get_score.html","id":null,"dir":"Reference","previous_headings":"","what":"Get score function from problem — get_score","title":"Get score function from problem — get_score","text":"Returns score (gradient) function, computing numerically provided. cache_derivatives = TRUE set problem score computed numerically, results cached using single-value cache.","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/get_score.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get score function from problem — get_score","text":"","code":"get_score(problem)"},{"path":"https://queelius.github.io/compositional.mle/reference/get_score.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get score function from problem — get_score","text":"problem mle_problem object","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/get_score.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get score function from problem — get_score","text":"Score function takes parameter vector returns   gradient log-likelihood.","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/get_score.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get score function from problem — get_score","text":"","code":"problem <- mle_problem(   loglike = function(theta) -sum((theta - c(1, 2))^2) ) score_fn <- get_score(problem) score_fn(c(0, 0))  # Gradient at (0, 0) #> [1] 2 4"},{"path":"https://queelius.github.io/compositional.mle/reference/gradient_ascent.html","id":null,"dir":"Reference","previous_headings":"","what":"Gradient Ascent Solver — gradient_ascent","title":"Gradient Ascent Solver — gradient_ascent","text":"Creates solver uses gradient ascent (steepest ascent) find MLE. Optionally uses backtracking line search adaptive step sizes.","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/gradient_ascent.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Gradient Ascent Solver — gradient_ascent","text":"","code":"gradient_ascent(   learning_rate = 1,   line_search = TRUE,   max_iter = 100L,   tol = 1e-08,   backtrack_ratio = 0.5,   min_step = 1e-12,   verbose = FALSE )"},{"path":"https://queelius.github.io/compositional.mle/reference/gradient_ascent.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Gradient Ascent Solver — gradient_ascent","text":"learning_rate Base learning rate / maximum step size line_search Use backtracking line search adaptive step sizes max_iter Maximum number iterations tol Convergence tolerance (parameter change) backtrack_ratio Step size reduction factor line search (0 < r < 1) min_step Minimum step size giving verbose Logical; TRUE cli package installed, display progress optimization. Default FALSE.","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/gradient_ascent.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Gradient Ascent Solver — gradient_ascent","text":"solver function signature (problem, theta0, trace) -> mle_result","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/gradient_ascent.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Gradient Ascent Solver — gradient_ascent","text":"Gradient ascent iteratively moves direction score (gradient log-likelihood). line search enabled, step size adaptively chosen ensure log-likelihood increases. solver respects constraints defined problem via projection.","code":""},{"path":[]},{"path":"https://queelius.github.io/compositional.mle/reference/gradient_ascent.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Gradient Ascent Solver — gradient_ascent","text":"","code":"# Create a solver with default parameters solver <- gradient_ascent()  # Create a solver with custom parameters solver <- gradient_ascent(   learning_rate = 0.5,   max_iter = 500,   tol = 1e-10 )  # Without line search (fixed step size) solver <- gradient_ascent(learning_rate = 0.01, line_search = FALSE)"},{"path":"https://queelius.github.io/compositional.mle/reference/grapes-greater-than-greater-than-grapes.html","id":null,"dir":"Reference","previous_headings":"","what":"Sequential Solver Composition — %>>%","title":"Sequential Solver Composition — %>>%","text":"Chains two solvers sequentially. result first solver becomes starting point second. enables coarse--fine strategies.","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/grapes-greater-than-greater-than-grapes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sequential Solver Composition — %>>%","text":"","code":"s1 %>>% s2"},{"path":"https://queelius.github.io/compositional.mle/reference/grapes-greater-than-greater-than-grapes.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sequential Solver Composition — %>>%","text":"s1 First solver function s2 Second solver function","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/grapes-greater-than-greater-than-grapes.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sequential Solver Composition — %>>%","text":"new solver function runs s1 s2","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/grapes-greater-than-greater-than-grapes.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Sequential Solver Composition — %>>%","text":"Trace data solvers chain merged single trace stage boundaries preserved.","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/grapes-greater-than-greater-than-grapes.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Sequential Solver Composition — %>>%","text":"","code":"# Coarse-to-fine: grid search to find good region, then gradient ascent strategy <- grid_search(lower = c(-10, 0.1), upper = c(10, 5), n = 5) %>>%   gradient_ascent()  # Three-stage refinement strategy <- grid_search(lower = c(-10, 0.1), upper = c(10, 5), n = 3) %>>%   gradient_ascent() %>>%   newton_raphson()"},{"path":"https://queelius.github.io/compositional.mle/reference/grid_search.html","id":null,"dir":"Reference","previous_headings":"","what":"Grid Search Solver — grid_search","title":"Grid Search Solver — grid_search","text":"Creates solver evaluates log-likelihood grid points returns best. Useful finding good starting points low-dimensional problems.","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/grid_search.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Grid Search Solver — grid_search","text":"","code":"grid_search(lower, upper, n = 10L)"},{"path":"https://queelius.github.io/compositional.mle/reference/grid_search.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Grid Search Solver — grid_search","text":"lower Lower bounds grid upper Upper bounds grid n Number points per dimension (scalar vector)","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/grid_search.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Grid Search Solver — grid_search","text":"solver function signature (problem, theta0, trace) -> mle_result","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/grid_search.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Grid Search Solver — grid_search","text":"Grid search deterministic exhaustive within bounds. useful 1-3 dimensional problems first stage multi-stage strategy (e.g., grid_search theta0 argument ignored; grid determined lower/upper/n. Points outside problem's constraint support skipped.","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/grid_search.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Grid Search Solver — grid_search","text":"","code":"# \\donttest{ set.seed(42) x <- rnorm(50, 5, 2) problem <- mle_problem(   loglike = function(theta) sum(dnorm(x, theta[1], theta[2], log = TRUE)),   constraint = mle_constraint(support = function(theta) theta[2] > 0,                               project = function(theta) c(theta[1], max(theta[2], 1e-8))) ) # Simple grid search solver <- grid_search(lower = c(-10, 0.1), upper = c(10, 5), n = 20) result <- solver(problem, c(0, 1))  # Coarse-to-fine: grid then gradient strategy <- grid_search(c(-10, 0.1), c(10, 5), n = 5) %>>% gradient_ascent() # }"},{"path":"https://queelius.github.io/compositional.mle/reference/is_converged.html","id":null,"dir":"Reference","previous_headings":"","what":"Check if solver converged — is_converged","title":"Check if solver converged — is_converged","text":"Check solver converged","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/is_converged.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check if solver converged — is_converged","text":"","code":"is_converged(x, ...)"},{"path":"https://queelius.github.io/compositional.mle/reference/is_converged.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check if solver converged — is_converged","text":"x mle result object ... Additional arguments (unused)","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/is_converged.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check if solver converged — is_converged","text":"Logical indicating convergence","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/is_converged.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check if solver converged — is_converged","text":"","code":"# \\donttest{ problem <- mle_problem(   loglike = function(theta) -sum((theta - c(1, 2))^2) ) result <- gradient_ascent(max_iter = 50)(problem, c(0, 0)) is_converged(result) #> [1] TRUE # }"},{"path":"https://queelius.github.io/compositional.mle/reference/is_mle_constraint.html","id":null,"dir":"Reference","previous_headings":"","what":"Check if object is an mle_constraint — is_mle_constraint","title":"Check if object is an mle_constraint — is_mle_constraint","text":"Check object mle_constraint","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/is_mle_constraint.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check if object is an mle_constraint — is_mle_constraint","text":"","code":"is_mle_constraint(x)"},{"path":"https://queelius.github.io/compositional.mle/reference/is_mle_constraint.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check if object is an mle_constraint — is_mle_constraint","text":"x Object test","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/is_mle_constraint.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check if object is an mle_constraint — is_mle_constraint","text":"Logical indicating whether x mle_constraint.","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/is_mle_constraint.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check if object is an mle_constraint — is_mle_constraint","text":"","code":"constraint <- mle_constraint(support = function(theta) all(theta > 0)) is_mle_constraint(constraint)  # TRUE #> [1] TRUE is_mle_constraint(list())      # FALSE #> [1] FALSE"},{"path":"https://queelius.github.io/compositional.mle/reference/is_mle_numerical.html","id":null,"dir":"Reference","previous_headings":"","what":"Check if object is an mle_numerical — is_mle_numerical","title":"Check if object is an mle_numerical — is_mle_numerical","text":"Check object mle_numerical","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/is_mle_numerical.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check if object is an mle_numerical — is_mle_numerical","text":"","code":"is_mle_numerical(x)"},{"path":"https://queelius.github.io/compositional.mle/reference/is_mle_numerical.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check if object is an mle_numerical — is_mle_numerical","text":"x Object test","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/is_mle_numerical.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check if object is an mle_numerical — is_mle_numerical","text":"Logical indicating whether x inherits mle_numerical.","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/is_mle_numerical.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check if object is an mle_numerical — is_mle_numerical","text":"","code":"# \\donttest{ problem <- mle_problem(   loglike = function(theta) -sum((theta - c(1, 2))^2) ) result <- gradient_ascent(max_iter = 20)(problem, c(0, 0)) is_mle_numerical(result)  # TRUE #> [1] TRUE is_mle_numerical(list())  # FALSE #> [1] FALSE # }"},{"path":"https://queelius.github.io/compositional.mle/reference/is_mle_problem.html","id":null,"dir":"Reference","previous_headings":"","what":"Check if object is an mle_problem — is_mle_problem","title":"Check if object is an mle_problem — is_mle_problem","text":"Check object mle_problem","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/is_mle_problem.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check if object is an mle_problem — is_mle_problem","text":"","code":"is_mle_problem(x)"},{"path":"https://queelius.github.io/compositional.mle/reference/is_mle_problem.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check if object is an mle_problem — is_mle_problem","text":"x Object test","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/is_mle_problem.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check if object is an mle_problem — is_mle_problem","text":"Logical indicating whether x mle_problem.","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/is_mle_problem.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check if object is an mle_problem — is_mle_problem","text":"","code":"problem <- mle_problem(   loglike = function(theta) -sum((theta - c(1, 2))^2) ) is_mle_problem(problem)  # TRUE #> [1] TRUE is_mle_problem(list())   # FALSE #> [1] FALSE"},{"path":"https://queelius.github.io/compositional.mle/reference/is_tracing.html","id":null,"dir":"Reference","previous_headings":"","what":"Check if tracing is enabled — is_tracing","title":"Check if tracing is enabled — is_tracing","text":"Check tracing enabled","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/is_tracing.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check if tracing is enabled — is_tracing","text":"","code":"is_tracing(trace)"},{"path":"https://queelius.github.io/compositional.mle/reference/is_tracing.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check if tracing is enabled — is_tracing","text":"trace mle_trace object","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/is_tracing.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check if tracing is enabled — is_tracing","text":"Logical indicating tracing enabled","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/is_tracing.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check if tracing is enabled — is_tracing","text":"","code":"# Tracing disabled (default) trace <- mle_trace() is_tracing(trace)  # FALSE #> [1] FALSE  # Tracing enabled trace <- mle_trace(values = TRUE) is_tracing(trace)  # TRUE #> [1] TRUE"},{"path":"https://queelius.github.io/compositional.mle/reference/lbfgsb.html","id":null,"dir":"Reference","previous_headings":"","what":"L-BFGS-B Solver (Box Constrained) — lbfgsb","title":"L-BFGS-B Solver (Box Constrained) — lbfgsb","text":"Creates solver using L-BFGS-B, limited-memory BFGS variant supports box constraints (lower upper bounds parameters).","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/lbfgsb.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"L-BFGS-B Solver (Box Constrained) — lbfgsb","text":"","code":"lbfgsb(lower = -Inf, upper = Inf, max_iter = 100L, tol = 1e-08)"},{"path":"https://queelius.github.io/compositional.mle/reference/lbfgsb.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"L-BFGS-B Solver (Box Constrained) — lbfgsb","text":"lower Lower bounds parameters (can -Inf) upper Upper bounds parameters (can Inf) max_iter Maximum number iterations tol Convergence tolerance","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/lbfgsb.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"L-BFGS-B Solver (Box Constrained) — lbfgsb","text":"solver function","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/lbfgsb.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"L-BFGS-B Solver (Box Constrained) — lbfgsb","text":"Unlike constraint system mle_problem (uses projection), L-BFGS-B handles box constraints natively within algorithm. Use simple bound constraints.","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/lbfgsb.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"L-BFGS-B Solver (Box Constrained) — lbfgsb","text":"","code":"# \\donttest{ set.seed(42) x <- rnorm(50, 5, 2) problem <- mle_problem(   loglike = function(theta) sum(dnorm(x, theta[1], theta[2], log = TRUE)) ) # Positive sigma via box constraint solver <- lbfgsb(lower = c(-Inf, 0.01), upper = c(Inf, Inf)) result <- solver(problem, c(4, 1.5)) # }"},{"path":"https://queelius.github.io/compositional.mle/reference/merge_traces.html","id":null,"dir":"Reference","previous_headings":"","what":"Merge trace data from multiple results — merge_traces","title":"Merge trace data from multiple results — merge_traces","text":"Concatenates trace data sequence results (e.g., composed solvers). merged trace preserves stage boundaries later analysis.","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/merge_traces.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Merge trace data from multiple results — merge_traces","text":"","code":"merge_traces(results)"},{"path":"https://queelius.github.io/compositional.mle/reference/merge_traces.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Merge trace data from multiple results — merge_traces","text":"results List mle_numerical results trace_data","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/merge_traces.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Merge trace data from multiple results — merge_traces","text":"merged mle_trace_data object stage information","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/mle_constraint.html","id":null,"dir":"Reference","previous_headings":"","what":"Create domain constraint specification — mle_constraint","title":"Create domain constraint specification — mle_constraint","text":"Specifies domain constraints optimization. support function checks parameters valid, project function maps invalid parameters back valid ones.","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/mle_constraint.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create domain constraint specification — mle_constraint","text":"","code":"mle_constraint(support = function(theta) TRUE, project = function(theta) theta)"},{"path":"https://queelius.github.io/compositional.mle/reference/mle_constraint.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create domain constraint specification — mle_constraint","text":"support Function testing theta support (returns TRUE/FALSE) project Function projecting theta onto support","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/mle_constraint.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create domain constraint specification — mle_constraint","text":"mle_constraint object","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/mle_constraint.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create domain constraint specification — mle_constraint","text":"","code":"# Positive parameters only constraint <- mle_constraint(   support = function(theta) all(theta > 0),   project = function(theta) pmax(theta, 1e-8) )  # Parameters in [0, 1] constraint <- mle_constraint(   support = function(theta) all(theta >= 0 & theta <= 1),   project = function(theta) pmax(0, pmin(1, theta)) )  # No constraints (default) constraint <- mle_constraint()"},{"path":"https://queelius.github.io/compositional.mle/reference/mle_problem.html","id":null,"dir":"Reference","previous_headings":"","what":"Create an MLE Problem Specification — mle_problem","title":"Create an MLE Problem Specification — mle_problem","text":"Encapsulates maximum likelihood estimation problem, separating statistical specification optimization strategy.","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/mle_problem.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create an MLE Problem Specification — mle_problem","text":"","code":"mle_problem(   loglike,   score = NULL,   fisher = NULL,   constraint = NULL,   theta_names = NULL,   n_obs = NULL,   cache_derivatives = FALSE )  # S3 method for class 'mle_problem' print(x, ...)"},{"path":"https://queelius.github.io/compositional.mle/reference/mle_problem.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create an MLE Problem Specification — mle_problem","text":"loglike Log-likelihood function taking parameter vector theta score Score function (gradient log-likelihood). NULL, computed numerically via numDeriv::grad needed. fisher Fisher information matrix function. NULL, computed numerically via numDeriv::hessian needed. constraint Domain constraints mle_constraint object theta_names Character vector parameter names nice output n_obs Number observations (AIC/BIC computation) cache_derivatives Logical; TRUE score/fisher computed numerically, cache recent result avoid redundant computation. particularly useful line search point may evaluated multiple times. Default FALSE. x mle_problem object. ... Additional arguments (unused).","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/mle_problem.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create an MLE Problem Specification — mle_problem","text":"mle_problem object input object, invisibly (method chaining).","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/mle_problem.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create an MLE Problem Specification — mle_problem","text":"problem object provides lazy evaluation derivatives. provide analytic score fisher functions, computed numerically requested. cache_derivatives = TRUE, numerical derivatives cached using single-value cache (stores recent theta result). efficient optimization consecutive calls often evaluate point (e.g., line search convergence checking). Use clear_cache manually clear cache needed.","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/mle_problem.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create an MLE Problem Specification — mle_problem","text":"","code":"# With analytic derivatives problem <- mle_problem(   loglike = function(theta) sum(dnorm(data, theta[1], theta[2], log = TRUE)),   score = function(theta) {     c(sum(data - theta[1]) / theta[2]^2,       -length(data)/theta[2] + sum((data - theta[1])^2) / theta[2]^3)   },   constraint = mle_constraint(     support = function(theta) theta[2] > 0,     project = function(theta) c(theta[1], max(theta[2], 1e-8))   ),   theta_names = c(\"mu\", \"sigma\") )  # Without analytic derivatives (computed numerically) problem <- mle_problem(   loglike = function(theta) sum(dnorm(data, theta[1], theta[2], log = TRUE)),   constraint = mle_constraint(     support = function(theta) theta[2] > 0   ) )"},{"path":"https://queelius.github.io/compositional.mle/reference/mle_trace.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a Trace Configuration — mle_trace","title":"Create a Trace Configuration — mle_trace","text":"Specifies information track optimization.","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/mle_trace.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a Trace Configuration — mle_trace","text":"","code":"mle_trace(   values = FALSE,   path = FALSE,   gradients = FALSE,   timing = FALSE,   every = 1L )  # S3 method for class 'mle_trace' print(x, ...)"},{"path":"https://queelius.github.io/compositional.mle/reference/mle_trace.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a Trace Configuration — mle_trace","text":"values Track log-likelihood values iteration path Track parameter values iteration gradients Track gradient norms iteration timing Track wall-clock time every Record every nth iteration (1 = iterations) x mle_trace object. ... Additional arguments (unused).","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/mle_trace.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a Trace Configuration — mle_trace","text":"mle_trace configuration object input object, invisibly (method chaining).","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/mle_trace.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a Trace Configuration — mle_trace","text":"","code":"# Track everything trace <- mle_trace(values = TRUE, path = TRUE, gradients = TRUE)  # Minimal tracing (just convergence path) trace <- mle_trace(values = TRUE)  # Sample every 10th iteration for long runs trace <- mle_trace(values = TRUE, path = TRUE, every = 10)"},{"path":"https://queelius.github.io/compositional.mle/reference/nelder_mead.html","id":null,"dir":"Reference","previous_headings":"","what":"Nelder-Mead Solver (Derivative-Free) — nelder_mead","title":"Nelder-Mead Solver (Derivative-Free) — nelder_mead","text":"Creates solver using Nelder-Mead simplex method via optim(). derivative-free method useful gradients unavailable unreliable.","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/nelder_mead.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Nelder-Mead Solver (Derivative-Free) — nelder_mead","text":"","code":"nelder_mead(max_iter = 500L, tol = 1e-08)"},{"path":"https://queelius.github.io/compositional.mle/reference/nelder_mead.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Nelder-Mead Solver (Derivative-Free) — nelder_mead","text":"max_iter Maximum number iterations tol Convergence tolerance","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/nelder_mead.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Nelder-Mead Solver (Derivative-Free) — nelder_mead","text":"solver function","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/nelder_mead.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Nelder-Mead Solver (Derivative-Free) — nelder_mead","text":"Nelder-Mead use gradient information, making robust potentially slower. useful fallback gradient-based methods fail, problems non-smooth likelihoods.","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/nelder_mead.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Nelder-Mead Solver (Derivative-Free) — nelder_mead","text":"","code":"# \\donttest{ set.seed(42) x <- rnorm(50, 5, 2) problem <- mle_problem(   loglike = function(theta) sum(dnorm(x, theta[1], theta[2], log = TRUE)),   constraint = mle_constraint(support = function(theta) theta[2] > 0,                               project = function(theta) c(theta[1], max(theta[2], 1e-8))) ) # Use when gradients are problematic result <- nelder_mead()(problem, c(4, 1.5))  # Race against gradient methods strategy <- gradient_ascent() %|% nelder_mead() # }"},{"path":"https://queelius.github.io/compositional.mle/reference/new_trace_recorder.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a trace recorder — new_trace_recorder","title":"Create a trace recorder — new_trace_recorder","text":"Internal function create mutable trace recorder.","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/new_trace_recorder.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a trace recorder — new_trace_recorder","text":"","code":"new_trace_recorder(trace, n_params)"},{"path":"https://queelius.github.io/compositional.mle/reference/new_trace_recorder.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a trace recorder — new_trace_recorder","text":"trace mle_trace configuration n_params Number parameters (pre-allocation)","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/new_trace_recorder.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a trace recorder — new_trace_recorder","text":"trace recorder environment","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/newton_raphson.html","id":null,"dir":"Reference","previous_headings":"","what":"Newton-Raphson Solver — newton_raphson","title":"Newton-Raphson Solver — newton_raphson","text":"Creates solver uses Newton-Raphson (second-order) optimization. Uses Fisher information matrix scale gradient faster convergence near optimum.","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/newton_raphson.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Newton-Raphson Solver — newton_raphson","text":"","code":"newton_raphson(   line_search = TRUE,   max_iter = 50L,   tol = 1e-08,   backtrack_ratio = 0.5,   min_step = 1e-12,   verbose = FALSE )"},{"path":"https://queelius.github.io/compositional.mle/reference/newton_raphson.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Newton-Raphson Solver — newton_raphson","text":"line_search Use backtracking line search stability max_iter Maximum number iterations tol Convergence tolerance (parameter change) backtrack_ratio Step size reduction factor line search min_step Minimum step size giving verbose Logical; TRUE cli package installed, display progress optimization. Default FALSE.","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/newton_raphson.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Newton-Raphson Solver — newton_raphson","text":"solver function signature (problem, theta0, trace) -> mle_result","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/newton_raphson.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Newton-Raphson Solver — newton_raphson","text":"Newton-Raphson computes search direction \\((\\theta)^{-1} s(\\theta)\\) \\(\\) Fisher information \\(s\\) score. accounts parameter scaling typically converges faster gradient ascent near optimum. Requires problem Fisher information function (either analytic computed numerically).","code":""},{"path":[]},{"path":"https://queelius.github.io/compositional.mle/reference/newton_raphson.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Newton-Raphson Solver — newton_raphson","text":"","code":"# \\donttest{ set.seed(42) x <- rnorm(50, 5, 2) problem <- mle_problem(   loglike = function(theta) sum(dnorm(x, theta[1], theta[2], log = TRUE)),   constraint = mle_constraint(support = function(theta) theta[2] > 0,                               project = function(theta) c(theta[1], max(theta[2], 1e-8))) ) # Basic usage solver <- newton_raphson() result <- solver(problem, c(4, 1.5))  # Often used after gradient ascent for refinement strategy <- gradient_ascent(max_iter = 50) %>>% newton_raphson(max_iter = 20) # }"},{"path":"https://queelius.github.io/compositional.mle/reference/normal_sampler.html","id":null,"dir":"Reference","previous_headings":"","what":"Normal Sampler Factory — normal_sampler","title":"Normal Sampler Factory — normal_sampler","text":"Creates sampler function use with_restarts generates normally distributed starting points around center.","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/normal_sampler.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Normal Sampler Factory — normal_sampler","text":"","code":"normal_sampler(center, sd = 1)"},{"path":"https://queelius.github.io/compositional.mle/reference/normal_sampler.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Normal Sampler Factory — normal_sampler","text":"center Mean normal distribution sd Standard deviation (scalar vector)","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/normal_sampler.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Normal Sampler Factory — normal_sampler","text":"sampler function","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/normal_sampler.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Normal Sampler Factory — normal_sampler","text":"","code":"sampler <- normal_sampler(c(0, 1), sd = c(5, 0.5)) strategy <- with_restarts(gradient_ascent(), n = 20, sampler = sampler)"},{"path":"https://queelius.github.io/compositional.mle/reference/num_iterations.html","id":null,"dir":"Reference","previous_headings":"","what":"Get number of iterations — num_iterations","title":"Get number of iterations — num_iterations","text":"Get number iterations","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/num_iterations.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get number of iterations — num_iterations","text":"","code":"num_iterations(x, ...)"},{"path":"https://queelius.github.io/compositional.mle/reference/num_iterations.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get number of iterations — num_iterations","text":"x mle result object ... Additional arguments (unused)","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/num_iterations.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get number of iterations — num_iterations","text":"Number iterations, NA_integer_ available.","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/num_iterations.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get number of iterations — num_iterations","text":"","code":"# \\donttest{ problem <- mle_problem(   loglike = function(theta) -sum((theta - c(1, 2))^2) ) result <- gradient_ascent(max_iter = 50)(problem, c(0, 0)) num_iterations(result) #> [1] 14 # }"},{"path":"https://queelius.github.io/compositional.mle/reference/optimization_path.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract Optimization Path as Data Frame — optimization_path","title":"Extract Optimization Path as Data Frame — optimization_path","text":"Converts trace data MLE result tidy data frame custom analysis plotting (e.g., ggplot2).","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/optimization_path.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract Optimization Path as Data Frame — optimization_path","text":"","code":"optimization_path(x, ...)"},{"path":"https://queelius.github.io/compositional.mle/reference/optimization_path.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract Optimization Path as Data Frame — optimization_path","text":"x mle_numerical result trace_data, mle_trace_data object ... Additional arguments (unused)","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/optimization_path.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract Optimization Path as Data Frame — optimization_path","text":"data frame columns: iteration: Iteration number loglike: Log-likelihood value (traced) grad_norm: Gradient norm (traced) time: Elapsed time seconds (traced) theta_1, theta_2, ...: Parameter values (path traced)","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/optimization_path.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract Optimization Path as Data Frame — optimization_path","text":"","code":"# \\donttest{ # Get optimization path as data frame problem <- mle_problem(   loglike = function(theta) -sum((theta - c(3, 2))^2),   constraint = mle_constraint(support = function(theta) TRUE) ) trace_cfg <- mle_trace(values = TRUE, path = TRUE) result <- gradient_ascent(max_iter = 30)(problem, c(0, 0), trace = trace_cfg)  path_df <- optimization_path(result) head(path_df) #>   iteration      loglike   theta_1   theta_2 #> 1         1 -13.00000000 0.0000000 0.0000000 #> 2         2  -6.78889745 0.8320503 0.5547002 #> 3         3  -2.57779490 1.6641006 1.1094004 #> 4         4  -0.36669235 2.4961509 1.6641006 #> 5         5  -0.15558980 3.3282012 2.2188008 #> 6         6  -0.01114107 2.9121760 1.9414507 # }"},{"path":"https://queelius.github.io/compositional.mle/reference/penalty_elastic_net.html","id":null,"dir":"Reference","previous_headings":"","what":"Elastic net penalty (combination of L1 and L2) — penalty_elastic_net","title":"Elastic net penalty (combination of L1 and L2) — penalty_elastic_net","text":"Creates penalty combining L1 L2 norms. parameter alpha controls balance: alpha=1 pure LASSO, alpha=0 pure Ridge.","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/penalty_elastic_net.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Elastic net penalty (combination of L1 and L2) — penalty_elastic_net","text":"","code":"penalty_elastic_net(alpha = 0.5, weights = NULL)"},{"path":"https://queelius.github.io/compositional.mle/reference/penalty_elastic_net.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Elastic net penalty (combination of L1 and L2) — penalty_elastic_net","text":"alpha Balance L1 L2 (numeric [0,1], default: 0.5) weights Optional parameter weights (default: 1)","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/penalty_elastic_net.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Elastic net penalty (combination of L1 and L2) — penalty_elastic_net","text":"Penalty function","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/penalty_elastic_net.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Elastic net penalty (combination of L1 and L2) — penalty_elastic_net","text":"","code":"# Equal mix of L1 and L2 penalty <- penalty_elastic_net(alpha = 0.5)  # More L1 (more sparsity) penalty <- penalty_elastic_net(alpha = 0.9)  # More L2 (more shrinkage) penalty <- penalty_elastic_net(alpha = 0.1)"},{"path":"https://queelius.github.io/compositional.mle/reference/penalty_l1.html","id":null,"dir":"Reference","previous_headings":"","what":"L1 penalty function (LASSO) — penalty_l1","title":"L1 penalty function (LASSO) — penalty_l1","text":"Creates penalty function computes L1 norm (sum absolute values). Used sparsity-inducing regularization.","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/penalty_l1.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"L1 penalty function (LASSO) — penalty_l1","text":"","code":"penalty_l1(weights = NULL)"},{"path":"https://queelius.github.io/compositional.mle/reference/penalty_l1.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"L1 penalty function (LASSO) — penalty_l1","text":"weights Optional parameter weights (default: 1)","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/penalty_l1.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"L1 penalty function (LASSO) — penalty_l1","text":"Penalty function","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/penalty_l1.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"L1 penalty function (LASSO) — penalty_l1","text":"","code":"penalty <- penalty_l1() penalty(c(1, -2, 3))  # Returns 6 #> [1] 6  # Weighted L1 penalty <- penalty_l1(weights = c(1, 2, 1)) penalty(c(1, -2, 3))  # Returns 1*1 + 2*2 + 1*3 = 8 #> [1] 8"},{"path":"https://queelius.github.io/compositional.mle/reference/penalty_l2.html","id":null,"dir":"Reference","previous_headings":"","what":"L2 penalty function (Ridge) — penalty_l2","title":"L2 penalty function (Ridge) — penalty_l2","text":"Creates penalty function computes L2 norm squared (sum squares). Used parameter shrinkage.","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/penalty_l2.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"L2 penalty function (Ridge) — penalty_l2","text":"","code":"penalty_l2(weights = NULL)"},{"path":"https://queelius.github.io/compositional.mle/reference/penalty_l2.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"L2 penalty function (Ridge) — penalty_l2","text":"weights Optional parameter weights (default: 1)","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/penalty_l2.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"L2 penalty function (Ridge) — penalty_l2","text":"Penalty function","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/penalty_l2.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"L2 penalty function (Ridge) — penalty_l2","text":"","code":"penalty <- penalty_l2() penalty(c(1, -2, 3))  # Returns 14 #> [1] 14  # Weighted L2 penalty <- penalty_l2(weights = c(1, 2, 1)) penalty(c(1, -2, 3))  # Returns 1^2 + (2*2)^2 + 3^2 = 26 #> [1] 26"},{"path":"https://queelius.github.io/compositional.mle/reference/plot.mle_numerical.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot Optimization Convergence — plot.mle_numerical","title":"Plot Optimization Convergence — plot.mle_numerical","text":"Visualizes optimization trajectory MLE result tracing enabled. Shows log-likelihood progression, gradient norm decay, optionally parameter path (2D problems).","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/plot.mle_numerical.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot Optimization Convergence — plot.mle_numerical","text":"","code":"# S3 method for class 'mle_numerical' plot(x, which = c(\"loglike\", \"gradient\"), main = NULL, ...)"},{"path":"https://queelius.github.io/compositional.mle/reference/plot.mle_numerical.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot Optimization Convergence — plot.mle_numerical","text":"x mle_numerical result object trace_data Character vector specifying plots show: \"loglike\" (log-likelihood), \"gradient\" (gradient norm), \"path\" (2D parameter path) main Optional title ... Additional arguments passed plot","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/plot.mle_numerical.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot Optimization Convergence — plot.mle_numerical","text":"Invisibly returns trace data","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/plot.mle_numerical.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plot Optimization Convergence — plot.mle_numerical","text":"function requires solver run tracing enabled via mle_trace(). Without trace data, function warn return invisibly. \"path\" plot shown 2D parameter problems.","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/plot.mle_numerical.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot Optimization Convergence — plot.mle_numerical","text":"","code":"# \\donttest{ # Enable tracing when solving problem <- mle_problem(   loglike = function(theta) -sum((theta - c(3, 2))^2),   constraint = mle_constraint(support = function(theta) TRUE) ) trace_cfg <- mle_trace(values = TRUE, gradients = TRUE, path = TRUE) result <- gradient_ascent(max_iter = 50)(problem, c(0, 0), trace = trace_cfg)  # Plot convergence diagnostics plot(result)  # }"},{"path":"https://queelius.github.io/compositional.mle/reference/plot.mle_trace_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot Trace Data Directly — plot.mle_trace_data","title":"Plot Trace Data Directly — plot.mle_trace_data","text":"Plot Trace Data Directly","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/plot.mle_trace_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot Trace Data Directly — plot.mle_trace_data","text":"","code":"# S3 method for class 'mle_trace_data' plot(x, ...)"},{"path":"https://queelius.github.io/compositional.mle/reference/plot.mle_trace_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot Trace Data Directly — plot.mle_trace_data","text":"x mle_trace_data object ... Arguments passed plotting functions","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/plot.mle_trace_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot Trace Data Directly — plot.mle_trace_data","text":"Called side effects (generates plot). Returns input   object invisibly.","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/print.mle_trace_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Print MLE Trace Data — print.mle_trace_data","title":"Print MLE Trace Data — print.mle_trace_data","text":"Print MLE Trace Data","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/print.mle_trace_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print MLE Trace Data — print.mle_trace_data","text":"","code":"# S3 method for class 'mle_trace_data' print(x, ...)"},{"path":"https://queelius.github.io/compositional.mle/reference/print.mle_trace_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print MLE Trace Data — print.mle_trace_data","text":"x mle_trace_data object. ... Additional arguments (unused).","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/print.mle_trace_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print MLE Trace Data — print.mle_trace_data","text":"input object, invisibly (method chaining).","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/race.html","id":null,"dir":"Reference","previous_headings":"","what":"Race Multiple Solvers — race","title":"Race Multiple Solvers — race","text":"Runs multiple solvers (optionally parallel) returns best result (highest log-likelihood). flexible %|% operator.","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/race.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Race Multiple Solvers — race","text":"","code":"race(..., parallel = FALSE)"},{"path":"https://queelius.github.io/compositional.mle/reference/race.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Race Multiple Solvers — race","text":"... Solver functions race parallel Logical; TRUE future package installed, solvers run parallel using current future plan. Default FALSE.","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/race.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Race Multiple Solvers — race","text":"new solver function races solvers picks best","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/race.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Race Multiple Solvers — race","text":"parallel = TRUE, solvers executed using future::future() results collected future::value(). current future plan determines parallelization happens (e.g., plan(multisession) multi-process execution). Failed solvers (throw errors) ignored. solvers fail, error thrown.","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/race.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Race Multiple Solvers — race","text":"","code":"# Race three methods sequentially strategy <- race(gradient_ascent(), bfgs(), nelder_mead()) #> Error in race(gradient_ascent(), bfgs(), nelder_mead()): could not find function \"race\"  # Race with parallel execution (requires future package) if (FALSE) { # \\dontrun{ future::plan(future::multisession) strategy <- race(gradient_ascent(), bfgs(), nelder_mead(), parallel = TRUE) } # }"},{"path":"https://queelius.github.io/compositional.mle/reference/race_operator.html","id":null,"dir":"Reference","previous_headings":"","what":"Parallel Solver Racing (Operator) — race_operator","title":"Parallel Solver Racing (Operator) — race_operator","text":"Runs multiple solvers returns best result (highest log-likelihood). Useful unsure method work best given problem.","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/race_operator.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Parallel Solver Racing (Operator) — race_operator","text":"","code":"s1 %|% s2"},{"path":"https://queelius.github.io/compositional.mle/reference/race_operator.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Parallel Solver Racing (Operator) — race_operator","text":"s1 First solver function s2 Second solver function","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/race_operator.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Parallel Solver Racing (Operator) — race_operator","text":"new solver function runs picks best","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/race_operator.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Parallel Solver Racing (Operator) — race_operator","text":"parallel execution 2 solvers, use race.","code":""},{"path":[]},{"path":"https://queelius.github.io/compositional.mle/reference/race_operator.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Parallel Solver Racing (Operator) — race_operator","text":"","code":"# Race gradient-based vs derivative-free strategy <- gradient_ascent() %|% nelder_mead()  # Race multiple methods strategy <- gradient_ascent() %|% bfgs() %|% nelder_mead()"},{"path":"https://queelius.github.io/compositional.mle/reference/random_search.html","id":null,"dir":"Reference","previous_headings":"","what":"Random Search Solver — random_search","title":"Random Search Solver — random_search","text":"Creates solver evaluates log-likelihood random points returns best. Useful high-dimensional problems grid search infeasible.","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/random_search.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Random Search Solver — random_search","text":"","code":"random_search(sampler, n = 100L)"},{"path":"https://queelius.github.io/compositional.mle/reference/random_search.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Random Search Solver — random_search","text":"sampler Function generating random parameter vectors n Number random points evaluate","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/random_search.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Random Search Solver — random_search","text":"solver function","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/random_search.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Random Search Solver — random_search","text":"Unlike grid search, random search scales better high dimensions. sampler generate points reasonable region; points outside problem's constraint support skipped.","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/random_search.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Random Search Solver — random_search","text":"","code":"# Create a random search solver with uniform sampling solver <- random_search(   sampler = uniform_sampler(c(-10, 0.1), c(10, 5)),   n = 100 )"},{"path":"https://queelius.github.io/compositional.mle/reference/record_iteration.html","id":null,"dir":"Reference","previous_headings":"","what":"Record an iteration to trace — record_iteration","title":"Record an iteration to trace — record_iteration","text":"Record iteration trace","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/record_iteration.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Record an iteration to trace — record_iteration","text":"","code":"record_iteration(recorder, theta, value = NULL, gradient = NULL)"},{"path":"https://queelius.github.io/compositional.mle/reference/record_iteration.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Record an iteration to trace — record_iteration","text":"recorder Trace recorder new_trace_recorder theta Current parameters value Current log-likelihood (NULL) gradient Current gradient (NULL)","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/sim_anneal.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulated Annealing Solver — sim_anneal","title":"Simulated Annealing Solver — sim_anneal","text":"Creates solver using simulated annealing global optimization. Simulated annealing can escape local optima probabilistically accepting worse solutions, acceptance probability decreasing time (controlled \"temperature\" parameter).","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/sim_anneal.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulated Annealing Solver — sim_anneal","text":"","code":"sim_anneal(   temp_init = 10,   cooling_rate = 0.95,   max_iter = 1000L,   neighbor_sd = 1,   min_temp = 1e-10,   verbose = FALSE )"},{"path":"https://queelius.github.io/compositional.mle/reference/sim_anneal.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulated Annealing Solver — sim_anneal","text":"temp_init Initial temperature (higher = exploration) cooling_rate Temperature reduction factor per iteration (0 < r < 1) max_iter Maximum number iterations neighbor_sd Standard deviation generating neighbor proposals min_temp Minimum temperature stopping verbose Logical; TRUE cli package installed, display progress optimization. Default FALSE.","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/sim_anneal.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulated Annealing Solver — sim_anneal","text":"solver function signature (problem, theta0, trace) -> mle_result","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/sim_anneal.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Simulated Annealing Solver — sim_anneal","text":"iteration: 1. Generate neighbor adding Gaussian noise current parameters 2. neighbor improves objective, accept 3. neighbor worse, accept probability exp(delta / temp) 4. Reduce temperature: temp = temp * cooling_rate algorithm stochastic may find different solutions different runs. best results, use with_restarts() combine local optimizer via %>>%.","code":""},{"path":[]},{"path":"https://queelius.github.io/compositional.mle/reference/sim_anneal.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulated Annealing Solver — sim_anneal","text":"","code":"# Basic simulated annealing solver <- sim_anneal()  # More exploration (higher initial temp, slower cooling) solver <- sim_anneal(temp_init = 100, cooling_rate = 0.999)  # Coarse global search, then local refinement strategy <- sim_anneal(max_iter = 500) %>>% gradient_ascent()"},{"path":"https://queelius.github.io/compositional.mle/reference/uniform_sampler.html","id":null,"dir":"Reference","previous_headings":"","what":"Uniform Sampler Factory — uniform_sampler","title":"Uniform Sampler Factory — uniform_sampler","text":"Creates sampler function use with_restarts generates uniformly distributed starting points.","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/uniform_sampler.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Uniform Sampler Factory — uniform_sampler","text":"","code":"uniform_sampler(lower, upper)"},{"path":"https://queelius.github.io/compositional.mle/reference/uniform_sampler.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Uniform Sampler Factory — uniform_sampler","text":"lower Lower bounds parameter upper Upper bounds parameter","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/uniform_sampler.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Uniform Sampler Factory — uniform_sampler","text":"sampler function","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/uniform_sampler.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Uniform Sampler Factory — uniform_sampler","text":"","code":"sampler <- uniform_sampler(c(-10, 0.1), c(10, 5)) strategy <- with_restarts(gradient_ascent(), n = 20, sampler = sampler)"},{"path":"https://queelius.github.io/compositional.mle/reference/unless_converged.html","id":null,"dir":"Reference","previous_headings":"","what":"Conditional Refinement — unless_converged","title":"Conditional Refinement — unless_converged","text":"Applies refinement solver first solver converge. refinement applied, trace data solvers merged.","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/unless_converged.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Conditional Refinement — unless_converged","text":"","code":"unless_converged(solver, refinement)"},{"path":"https://queelius.github.io/compositional.mle/reference/unless_converged.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Conditional Refinement — unless_converged","text":"solver Primary solver function refinement Solver use primary converge","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/unless_converged.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Conditional Refinement — unless_converged","text":"new solver function conditional refinement","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/unless_converged.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Conditional Refinement — unless_converged","text":"","code":"# Use Newton-Raphson to refine if gradient ascent doesn't converge strategy <- unless_converged(gradient_ascent(max_iter = 50), newton_raphson())"},{"path":"https://queelius.github.io/compositional.mle/reference/update.mle_problem.html","id":null,"dir":"Reference","previous_headings":"","what":"Update an mle_problem — update.mle_problem","title":"Update an mle_problem — update.mle_problem","text":"Create new problem fields updated.","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/update.mle_problem.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Update an mle_problem — update.mle_problem","text":"","code":"# S3 method for class 'mle_problem' update(object, ...)"},{"path":"https://queelius.github.io/compositional.mle/reference/update.mle_problem.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Update an mle_problem — update.mle_problem","text":"object mle_problem ... Named arguments update","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/update.mle_problem.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Update an mle_problem — update.mle_problem","text":"New mle_problem","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/verbose-utils.html","id":null,"dir":"Reference","previous_headings":"","what":"Verbose Output Utilities — verbose-utils","title":"Verbose Output Utilities — verbose-utils","text":"Internal functions progress reporting optimization.","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/with_penalty.html","id":null,"dir":"Reference","previous_headings":"","what":"Add penalty term to log-likelihood — with_penalty","title":"Add penalty term to log-likelihood — with_penalty","text":"Transforms log-likelihood subtracting penalty term. Useful regularized estimation (e.g., LASSO, Ridge regression).","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/with_penalty.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add penalty term to log-likelihood — with_penalty","text":"","code":"with_penalty(loglike, penalty, lambda = 1)"},{"path":"https://queelius.github.io/compositional.mle/reference/with_penalty.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add penalty term to log-likelihood — with_penalty","text":"loglike Base log-likelihood function penalty Penalty function taking theta returning numeric lambda Penalty weight (non-negative numeric, default: 1.0)","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/with_penalty.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add penalty term to log-likelihood — with_penalty","text":"Transformed log-likelihood function","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/with_penalty.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add penalty term to log-likelihood — with_penalty","text":"","code":"# \\donttest{ # Regression with L2 penalty (Ridge) loglike <- function(theta) -sum((theta - c(1, 2))^2)  # Add L2 penalty loglike_penalized <- with_penalty(   loglike,   penalty = penalty_l2(),   lambda = 0.1 ) loglike_penalized(c(1, 2))  # Evaluate penalized likelihood #> [1] -0.5 # }"},{"path":"https://queelius.github.io/compositional.mle/reference/with_restarts.html","id":null,"dir":"Reference","previous_headings":"","what":"Multiple Random Restarts — with_restarts","title":"Multiple Random Restarts — with_restarts","text":"Runs solver multiple starting points returns best result. Essential problems multiple local optima.","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/with_restarts.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Multiple Random Restarts — with_restarts","text":"","code":"with_restarts(solver, n, sampler, max_reject = 100L)"},{"path":"https://queelius.github.io/compositional.mle/reference/with_restarts.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Multiple Random Restarts — with_restarts","text":"solver solver function n Number restarts (including provided theta0) sampler Function generates random starting points. Called arguments, return parameter vector. Samples automatically constrained using problem$constraint. max_reject Maximum rejection attempts per sample projection","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/with_restarts.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Multiple Random Restarts — with_restarts","text":"new solver function restart capability","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/with_restarts.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Multiple Random Restarts — with_restarts","text":"sampler generates candidate starting points, automatically filtered/projected using problem's constraint. means samplers can simple distributions without constraint awareness.","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/with_restarts.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Multiple Random Restarts — with_restarts","text":"","code":"# 20 random restarts - constraint applied automatically from problem sampler <- uniform_sampler(c(-10, 0), c(10, 5)) strategy <- with_restarts(gradient_ascent(), n = 20, sampler = sampler)  # Can also compose with other operators strategy <- with_restarts(gradient_ascent(), n = 10, sampler = sampler) %>>%   newton_raphson()"},{"path":"https://queelius.github.io/compositional.mle/reference/with_subsampling.html","id":null,"dir":"Reference","previous_headings":"","what":"Create stochastic log-likelihood with subsampling — with_subsampling","title":"Create stochastic log-likelihood with subsampling — with_subsampling","text":"Transforms log-likelihood function use random subsample observations. Useful stochastic gradient ascent large datasets.","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/with_subsampling.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create stochastic log-likelihood with subsampling — with_subsampling","text":"","code":"with_subsampling(loglike, data, subsample_size, replace = FALSE)"},{"path":"https://queelius.github.io/compositional.mle/reference/with_subsampling.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create stochastic log-likelihood with subsampling — with_subsampling","text":"loglike Base log-likelihood function. accept theta data. data Observations (vector, matrix, data.frame) subsample_size Number observations sample per evaluation replace Sample replacement (logical, default: FALSE)","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/with_subsampling.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create stochastic log-likelihood with subsampling — with_subsampling","text":"Transformed log-likelihood function","code":""},{"path":"https://queelius.github.io/compositional.mle/reference/with_subsampling.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create stochastic log-likelihood with subsampling — with_subsampling","text":"","code":"# \\donttest{ # Original likelihood uses all data data <- rnorm(10000, mean = 5, sd = 2)  loglike <- function(theta, obs = data) {   sum(dnorm(obs, mean = theta[1], sd = theta[2], log = TRUE)) }  # Stochastic version uses random subsample loglike_stoch <- with_subsampling(   loglike,   data = data,   subsample_size = 100 )  # Each call uses different random subsample loglike_stoch(c(5, 2)) #> [1] -218.2995 loglike_stoch(c(5, 2))  # Different value #> [1] -213.796 # }"},{"path":[]},{"path":"https://queelius.github.io/compositional.mle/news/index.html","id":"cran-release-1-0-0","dir":"Changelog","previous_headings":"","what":"CRAN Release","title":"compositional.mle 1.0.0","text":"First CRAN release Moved algebraic.mle Imports Depends generics (params(), se(), confint(), loglik_val(), aic(), nparams(), vcov()) available immediately package loaded Converted \\dontrun{} \\donttest{} examples (CRAN policy) Added hypothesize Suggests Added CI via GitHub Actions","code":""},{"path":[]},{"path":"https://queelius.github.io/compositional.mle/news/index.html","id":"new-features-0-2-0","dir":"Changelog","previous_headings":"","what":"New Features","title":"compositional.mle 0.2.0","text":"Simulated annealing solver (sim_anneal()) Coordinate ascent solver (coordinate_ascent()) race() function explicit parallel solver racing future support chain() function sequential composition early stopping Convergence diagnostics: plot.mle_numerical() optimization_path() Derivative caching mle_problem() avoid redundant computation Verbose/progress output via cli long-running solvers Trace aggregation merge_traces() across composed solvers","code":""},{"path":"https://queelius.github.io/compositional.mle/news/index.html","id":"documentation-0-2-0","dir":"Changelog","previous_headings":"","what":"Documentation","title":"compositional.mle 0.2.0","text":"Four vignettes: getting-started, theory--intuition, case-studies, strategy-design pkgdown site https://queelius.github.io/compositional.mle/","code":""},{"path":"https://queelius.github.io/compositional.mle/news/index.html","id":"bug-fixes-0-2-0","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"compositional.mle 0.2.0","text":"Fixed R CMD check issues (missing imports, example errors) Fixed LICENSE copyright holder","code":""},{"path":"https://queelius.github.io/compositional.mle/news/index.html","id":"compositionalmle-010","dir":"Changelog","previous_headings":"","what":"compositional.mle 0.1.0","title":"compositional.mle 0.1.0","text":"Initial release core solver factories composition operators Solvers: gradient_ascent, newton_raphson, bfgs, lbfgsb, nelder_mead, grid_search, random_search Composition: %>>% (sequential), %|% (racing), with_restarts(), unless_converged() Problem specification mle_problem() constraint support Tracing system optimization iteration recording Penalty/regularization transformers (L1, L2, elastic net)","code":""}]
